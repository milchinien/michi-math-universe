<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asymptoten-Raserei</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #2a1a1a 0%, #3a1a2e 50%, #361a2e 100%);
            font-family: 'Orbitron', monospace;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
            transition: background 1s ease-in-out;
        }
        
        /* Dynamische Level-Hintergr√ºnde - Rot/Pink/Rosa/Lila Spektrum */
        body.level-1 { background: linear-gradient(135deg, #2a1a1a 0%, #3a1a2e 50%, #361a2e 100%); }
        body.level-2 { background: linear-gradient(135deg, #2a0a1a 0%, #3a0a2e 50%, #360a2e 100%); }
        body.level-3 { background: linear-gradient(135deg, #2a0a0a 0%, #3a0a1e 50%, #360a1e 100%); }
        body.level-4 { background: linear-gradient(135deg, #1a0a0a 0%, #2a0a1e 50%, #260a1e 100%); }
        body.level-5 { background: linear-gradient(135deg, #1a0a0a 0%, #1a0a1e 50%, #160a1e 100%); }
        body.level-6 { background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1e 50%, #160a1e 100%); }
        body.level-7 { background: linear-gradient(135deg, #0a0a0a 0%, #0a0a1e 50%, #0a0a1e 100%); }
        body.level-8 { background: linear-gradient(135deg, #0a0a0a 0%, #0a0a0e 50%, #0a0a1e 100%); }
        body.level-9 { background: linear-gradient(135deg, #0a0a0a 0%, #0a0a0a 50%, #0a0a1e 100%); }
        body.level-10 { background: linear-gradient(135deg, #0a0a0a 0%, #0a0a0a 50%, #0a0a0a 100%); }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #gameCanvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        
        .ui-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 10px #00ffff;
        }
        
        #score, #level, #lives {
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #function {
            font-size: 14px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            color: #888;
        }
        
        #gameOver, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 30px #ff00ff;
            display: none;
        }
        
        #gameOver h2, #levelComplete h2 {
            color: #ff00ff;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #ff00ff;
        }
        
        button {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            border: none;
            color: #000;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00ffff;
        }
        
        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00ffff; }
            to { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff; }
        }
        
        .pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #pauseMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 2px solid #00ffff;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 0 30px #00ffff;
            z-index: 1000;
        }
        
        #pauseMenu h2 {
            color: #00ffff;
            font-size: 28px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px #00ffff;
        }
        
        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .pause-buttons button {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            border: none;
            color: #000;
            padding: 15px 30px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            font-size: 16px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 200px;
        }
        
        .pause-buttons button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px #00ffff;
        }
    </style>
</head>
<body>
    <!-- Hintergrund-Effekte Canvas -->
    <canvas id="backgroundCanvas" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; pointer-events: none;"></canvas>
    
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div id="ui">
            <div class="ui-panel">
                <div id="score" class="glow">Score: 0</div>
                <div id="level">Level: 1</div>
                <div id="lives">Lives: 3</div>
            </div>
            <div class="ui-panel">
                <div id="function">f(x) = 1/(x-2)</div>
            </div>
        </div>
        
        <div id="controls">
            <p>‚Üê Bremsen | ‚Üí Beschleunigen | Leertaste: Sprung | R: Restart | P: Pause</p>
            <p style="font-size: 10px; margin-top: 5px;">üéØ Fahre automatisch! Springe √ºber gelbe L√ºcken, nutze pinke Asymptoten f√ºr Boosts!</p>
            <p style="font-size: 10px; margin-top: 5px;">üîß Level 8: 1/2 f√ºr Pfad-Wechsel | Level 10: Chaos-Effekte alle 2 Sekunden!</p>
            <p style="font-size: 10px; margin-top: 5px;">‚≠ê PERFECT TIMING: Bei jedem Sprung erscheint ein schrumpfender Kreis! Perfekter Moment = +500 Punkte!</p>
        </div>
        
        <div id="pauseMenu" style="display: none;">
            <h2>Spiel pausiert</h2>
            <div class="pause-buttons">
                <button onclick="game.resumeGame()">Weiterspielen</button>
                <button onclick="game.restart()">Neustart</button>
                <button onclick="game.showMainMenu()">Hauptmen√º</button>
            </div>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Score: <span id="finalScore">0</span></p>
            <button onclick="game.restart()">Nochmal spielen</button>
        </div>
        
        <div id="levelComplete">
            <h2>Level geschafft!</h2>
            <p>Bonus: <span id="levelBonus">0</span></p>
            <button onclick="game.nextLevel()">N√§chstes Level</button>
        </div>
    </div>

    <script>
        class BackgroundEffects {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.resizeCanvas();
                this.particles = [];
                this.scanlines = [];
                this.vignette = 0;
                this.level = 1;
                
                // Event-Listener f√ºr Canvas-Resize
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Initialisiere Effekte
                this.initEffects();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            initEffects() {
                // Scanlines erstellen
                for (let i = 0; i < this.canvas.height; i += 2) {
                    this.scanlines.push({
                        y: i,
                        alpha: Math.random() * 0.1 + 0.05
                    });
                }
                
                // Partikel erstellen - mehr und intensivere
                const baseParticleCount = 80; // Mehr Basis-Partikel
                for (let i = 0; i < baseParticleCount; i++) {
                    this.particles.push({
                        x: Math.random() * this.canvas.width,
                        y: Math.random() * this.canvas.height,
                        vx: (Math.random() - 0.5) * 0.8, // Schnellere Bewegung
                        vy: (Math.random() - 0.5) * 0.8,
                        size: Math.random() * 3 + 1.5, // Gr√∂√üere Partikel
                        alpha: Math.random() * 0.5 + 0.2, // Intensivere Transparenz
                        color: this.getRandomRetroColor()
                    });
                }
            }
            
            getRandomRetroColor() {
                const colors = [
                    { r: 255, g: 0, b: 255 },   // Magenta
                    { r: 255, g: 20, b: 147 },  // Deep Pink
                    { r: 255, g: 105, b: 180 }, // Hot Pink
                    { r: 255, g: 0, b: 127 },   // Rose
                    { r: 255, g: 0, b: 0 },     // Rot
                    { r: 128, g: 0, b: 128 },   // Lila
                    { r: 255, g: 20, b: 147 },  // Deep Pink
                    { r: 199, g: 21, b: 133 }   // Medium Violet Red
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            setLevel(level) {
                this.level = level;
                this.vignette = (level - 1) * 0.1; // Intensit√§t steigt mit dem Level
            }
            
            update() {
                // Partikel aktualisieren
                this.particles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Partikel am Rand zur√ºcksetzen
                    if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
                    if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
                    
                    // Partikel-Gr√∂√üe und Alpha variieren
                    particle.size = Math.max(0.5, particle.size + (Math.random() - 0.5) * 0.1);
                    particle.alpha = Math.max(0.05, particle.alpha + (Math.random() - 0.5) * 0.02);
                });
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Vignette-Effekt (wird mit dem Level intensiver) - Roter Schimmer
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, this.canvas.width / 2
                );
                const vignetteIntensity = this.vignette * 1.5; // Intensiver
                gradient.addColorStop(0, `rgba(255, 0, 127, ${vignetteIntensity * 0.3})`); // Rosa Schimmer in der Mitte
                gradient.addColorStop(0.5, `rgba(128, 0, 128, ${vignetteIntensity * 0.6})`); // Lila √úbergang
                gradient.addColorStop(1, `rgba(0, 0, 0, ${vignetteIntensity})`); // Schwarzer Rand
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Scanlines (Retro-TV-Effekt) - Intensiver und roter
                const scanlineIntensity = 0.15 + this.level * 0.03; // Steigert sich mit dem Level
                this.ctx.strokeStyle = `rgba(255, 0, 255, ${scanlineIntensity})`;
                this.ctx.lineWidth = 1 + this.level * 0.2; // Dickere Linien in h√∂heren Leveln
                this.scanlines.forEach(line => {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, line.y);
                    this.ctx.lineTo(this.canvas.width, line.y);
                    this.ctx.stroke();
                });
                
                // Partikel rendern
                this.particles.forEach(particle => {
                    this.ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                
                // Glitch-Effekt f√ºr h√∂here Level - Fr√ºher und intensiver
                if (this.level >= 5) {
                    this.renderGlitchEffect();
                }
                
                // Matrix-Regen f√ºr Level 10
                if (this.level === 10) {
                    this.renderMatrixRain();
                }
            }
            
            renderGlitchEffect() {
                // Zuf√§llige Glitch-Linien - Intensiver und h√§ufiger
                const glitchChance = 0.15 + this.level * 0.02; // H√§ufiger in h√∂heren Leveln
                if (Math.random() < glitchChance) {
                    const glitchY = Math.random() * this.canvas.height;
                    const glitchIntensity = 0.4 + this.level * 0.08; // Intensiver
                    this.ctx.strokeStyle = `rgba(255, 0, 255, ${glitchIntensity})`;
                    this.ctx.lineWidth = 3 + this.level * 0.3; // Dickere Linien
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, glitchY);
                    this.ctx.lineTo(this.canvas.width, glitchY);
                    this.ctx.stroke();
                    
                    // Zus√§tzliche Glitch-Bl√∂cke f√ºr h√∂here Level
                    if (this.level >= 7) {
                        this.renderGlitchBlocks();
                    }
                }
            }
            
            renderGlitchBlocks() {
                // Zuf√§llige Glitch-Bl√∂cke f√ºr zus√§tzliche Intensit√§t
                if (Math.random() < 0.3) {
                    const blockX = Math.random() * this.canvas.width;
                    const blockY = Math.random() * this.canvas.height;
                    const blockSize = 10 + Math.random() * 20;
                    
                    this.ctx.fillStyle = `rgba(255, 0, 127, ${0.6 + this.level * 0.05})`;
                    this.ctx.fillRect(blockX, blockY, blockSize, blockSize);
                }
            }
            
            renderMatrixRain() {
                // Matrix-√§hnliche fallende Zeichen - Intensiver und roter
                const rainIntensity = 0.5 + this.level * 0.08; // Intensiver
                this.ctx.fillStyle = `rgba(255, 0, 255, ${rainIntensity})`; // Magenta statt Gr√ºn
                this.ctx.font = `${14 + this.level}px monospace`; // Gr√∂√üere Schrift in h√∂heren Leveln
                
                // Mehr Zeichen in h√∂heren Leveln
                const charCount = 25 + this.level * 3;
                for (let i = 0; i < charCount; i++) {
                    const x = (i * 40) % this.canvas.width;
                    const y = (Date.now() * 0.015 + i * 25) % this.canvas.height;
                    
                    // Verschiedene Zeichen f√ºr mehr Variation
                    const chars = ['01', '10', '11', '00', 'XX', '//', '\\\\'];
                    const randomChar = chars[Math.floor(Math.random() * chars.length)];
                    
                    this.ctx.fillText(randomChar, x, y);
                }
                
                // Zus√§tzliche rote Glitch-Partikel f√ºr Level 10
                if (this.level === 10) {
                    this.renderIntenseGlitchParticles();
                }
            }
            
            renderIntenseGlitchParticles() {
                // Intensive Glitch-Partikel f√ºr das finale Level
                for (let i = 0; i < 15; i++) {
                    const x = Math.random() * this.canvas.width;
                    const y = Math.random() * this.canvas.height;
                    const size = Math.random() * 8 + 4;
                    
                    this.ctx.fillStyle = `rgba(255, 0, 0, ${0.7 + Math.random() * 0.3})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }
        }
        
        class MathEngine {
            constructor() {
                this.epsilon = 0.001;
            }
            
            parseFunction(functionString) {
                // Vereinfachter Parser f√ºr gebrochenrationale Funktionen
                const functions = {
                    1: { // Level 1: f(x) = 1/(x-2)
                        evaluate: (x) => 1 / (x - 2),
                        poles: [2],
                        asymptotes: { horizontal: 0, vertical: [2] },
                        discontinuities: []
                    },
                    2: { // Level 2: f(x) = 1/((x-1)(x+1))
                        evaluate: (x) => 1 / ((x - 1) * (x + 1)),
                        poles: [-1, 1],
                        asymptotes: { horizontal: 0, vertical: [-1, 1] },
                        discontinuities: []
                    },
                    3: { // Level 3: f(x) = (x-1)/((x-1)(x-2)) = 1/(x-2) mit L√ºcke bei x=1
                        evaluate: (x) => Math.abs(x - 1) < this.epsilon ? 1 : 1 / (x - 2),
                        poles: [2],
                        asymptotes: { horizontal: 0, vertical: [2] },
                        discontinuities: [1]
                    },
                    4: { // Level 4: f(x) = (x¬≤+1)/(x-1)
                        evaluate: (x) => (x * x + 1) / (x - 1),
                        poles: [1],
                        asymptotes: { horizontal: null, vertical: [1], oblique: { slope: 1, intercept: 1 } },
                        discontinuities: []
                    },
                    5: { // Level 5: f(x) = (x¬≤-4)/((x-1)(x+2)(x-3))
                        evaluate: (x) => (x * x - 4) / ((x - 1) * (x + 2) * (x - 3)),
                        poles: [-2, 1, 3],
                        asymptotes: { horizontal: 0, vertical: [-2, 1, 3] },
                        discontinuities: []
                    },
                    6: { // Level 6: f(x) = (x¬≥-2x)/(x¬≤-4) - Zeitverz√∂gerung
                        evaluate: (x) => (x * x * x - 2 * x) / (x * x - 4),
                        poles: [-2, 2],
                        asymptotes: { horizontal: null, vertical: [-2, 2], oblique: { slope: 1, intercept: 0 } },
                        discontinuities: [],
                        timeWarp: { zones: [-1, 1], factor: 0.3 } // Zeitlupe in diesen Zonen
                    },
                    7: { // Level 7: f(x) = 1/(x¬≤-1) - Gravitationswechsel
                        evaluate: (x) => 1 / (x * x - 1),
                        poles: [-1, 1],
                        asymptotes: { horizontal: 0, vertical: [-1, 1] },
                        discontinuities: [],
                        gravityZones: { 
                            left: { x: -3, strength: -0.8 }, // Schwerkraft nach oben
                            right: { x: 3, strength: 1.2 }   // Schwerkraft nach unten verst√§rkt
                        }
                    },
                    8: { // Level 8: f(x) = (x¬≤-1)/(x-1) - Multi-Path
                        evaluate: (x) => Math.abs(x - 1) < this.epsilon ? 2 : (x * x - 1) / (x - 1),
                        poles: [],
                        asymptotes: { horizontal: null, vertical: [], oblique: { slope: 1, intercept: 1 } },
                        discontinuities: [1],
                        multiPath: {
                            paths: [
                                { start: -2, end: 0.8, color: '#00ff00' },
                                { start: 1.2, end: 3, color: '#ff8800' }
                            ]
                        }
                    },
                    9: { // Level 9: f(x) = (x¬≥+1)/(x¬≤-1) - Inverser Boost
                        evaluate: (x) => (x * x * x + 1) / (x * x - 1),
                        poles: [-1, 1],
                        asymptotes: { horizontal: null, vertical: [-1, 1], oblique: { slope: 1, intercept: 0 } },
                        discontinuities: [],
                        inverseBoost: true // Asymptoten verlangsamen
                    },
                    10: { // Level 10: f(x) = (x‚Å¥-5x¬≤+4)/(x¬≥-2x¬≤-x+2) - Chaos-Modus
                        evaluate: (x) => (x * x * x * x - 5 * x * x + 4) / (x * x * x - 2 * x * x - x + 2),
                        poles: [-1, 1, 2],
                        asymptotes: { horizontal: null, vertical: [-1, 1, 2], oblique: { slope: 1, intercept: -1 } },
                        discontinuities: [],
                        chaosMode: true, // Zuf√§llige Effekte
                        chaosEffects: ['timeWarp', 'gravityShift', 'colorShift', 'sizeShift']
                    }
                };
                
                return functions[functionString] || functions[1];
            }
            
            isNearPole(x, poles) {
                return poles.some(pole => Math.abs(x - pole) < this.epsilon * 5);
            }
            
            isNearAsymptote(x, y, asymptotes) {
                // Pr√ºfe horizontale Asymptote
                if (asymptotes.horizontal !== null && Math.abs(y - asymptotes.horizontal) < 0.5) {
                    return true;
                }
                
                // Pr√ºfe schiefe Asymptote
                if (asymptotes.oblique) {
                    const asymptoteY = asymptotes.oblique.slope * x + asymptotes.oblique.intercept;
                    if (Math.abs(y - asymptoteY) < 0.5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            safeEvaluate(func, x) {
                try {
                    const result = func.evaluate(x);
                    if (!isFinite(result)) return null;
                    return result;
                } catch (e) {
                    return null;
                }
            }
        }
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = 8;
                this.trail = [];
                this.maxTrailLength = 20;
                this.jumping = false;
                this.jumpTime = 0;
                this.jumpDuration = 50; // Arc-Jump Dauer in Frames
                this.gravity = -0.006; // derzeit ungenutzt im Arc-Jump, behalten f√ºr evtl. future
                this.boostTime = 0;
                // Arc-Jump Parameter
                this.jumpStartX = 0;
                this.jumpStartY = 0;
                this.jumpTargetX = 0;
                this.jumpTargetY = 0;
                this.ctrlX = 0;
                this.ctrlY = 0;
                
                // Neue Eigenschaften f√ºr erweiterte Level
                this.chaosColor = null;
                this.chaosSize = 1;
            }
            
            update(mathEngine, currentFunction) {
                // Bewegung nur am Boden (im Arc-Jump steuern wir x/y direkt)
                if (!this.jumping) {
                    this.x += this.vx;
                }
                
                // Sprung-Logik
                if (this.jumping) {
                    this.jumpTime++;
                    const t = Math.min(1, this.jumpTime / this.jumpDuration);
                    const omt = 1 - t;
                    // Quadratischer Bezier-Bogen
                    this.x = omt * omt * this.jumpStartX + 2 * omt * t * this.ctrlX + t * t * this.jumpTargetX;
                    this.y = omt * omt * this.jumpStartY + 2 * omt * t * this.ctrlY + t * t * this.jumpTargetY;
                    if (t >= 1) {
                        this.jumping = false;
                        this.jumpTime = 0;
                        // Snap auf Kurve zur Sicherheit
                        const newY = mathEngine.safeEvaluate(currentFunction, this.x);
                        if (newY !== null) this.y = newY;
                    }
                }
                
                // Y-Position aus Funktion berechnen (wenn nicht springend)
                if (!this.jumping) {
                    const newY = mathEngine.safeEvaluate(currentFunction, this.x);
                    if (newY !== null) {
                        this.y = newY;
                    }
                }
                
                // Trail aktualisieren
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Boost-Timer
                if (this.boostTime > 0) {
                    this.boostTime--;
                }
            }
            
            startArcJump(targetX, targetY) {
                if (this.jumping) return;
                this.jumping = true;
                this.jumpTime = 0;
                this.jumpStartX = this.x;
                this.jumpStartY = this.y;
                this.jumpTargetX = targetX;
                this.jumpTargetY = targetY;
                // Kontrollpunkt in der Mitte mit zus√§tzlicher H√∂he f√ºr sch√∂nen Bogen
                const midX = (this.jumpStartX + this.jumpTargetX) / 2;
                const baseMidY = (this.jumpStartY + this.jumpTargetY) / 2;
                const arcHeight = Math.max(0.6, Math.abs(this.jumpTargetY - this.jumpStartY) * 0.8) + 0.6;
                this.ctrlX = midX;
                this.ctrlY = baseMidY + arcHeight; // nach oben (Welt-y nimmt zu)
            }
            
            checkCollisions(mathEngine, currentFunction, game) {
                // Polstellen-Kollision
                if (!this.jumping && mathEngine.isNearPole(this.x, currentFunction.poles)) {
                    return 'pole';
                }
                
                // Asymptoten-Boost
                if (mathEngine.isNearAsymptote(this.x, this.y, currentFunction.asymptotes)) {
                    if (this.boostTime === 0) {
                        this.boostTime = 60;
                        return 'boost';
                    }
                }
                
                // Definitionsl√ºcken - mit Sprungpuffer ("Coyote Time")
                for (let disc of currentFunction.discontinuities) {
                    if (Math.abs(this.x - disc) < 0.35) {
                        if (this.jumping || (game && game.jumpBuffer > 0)) {
                            if (game) game.jumpBuffer = 0; // Buffer verbrauchen
                            return 'discontinuity_success'; // Erfolgreicher Sprung
                        } else {
                            // In Level 3 kein Tod an der L√ºcke ‚Äì Teleporter √ºbernimmt
                            if (game && game.currentLevel === 3) {
                                return null;
                            }
                            return 'discontinuity_fail'; // In anderen Levels: Bestrafung
                        }
                    }
                }
                
                return null;
            }
        }
        
        class Renderer {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.scale = 50;
                this.offsetX = canvas.width / 2;
                this.offsetY = canvas.height / 2;
            }
            
            clear() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            worldToScreen(x, y) {
                return {
                    x: this.offsetX + x * this.scale,
                    y: this.offsetY - y * this.scale
                };
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                // Vertikale Linien
                for (let x = -10; x <= 10; x++) {
                    const screenX = this.offsetX + x * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, 0);
                    this.ctx.lineTo(screenX, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontale Linien
                for (let y = -6; y <= 6; y++) {
                    const screenY = this.offsetY - y * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                }
                
                // Achsen
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                
                // X-Achse
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.offsetY);
                this.ctx.lineTo(this.canvas.width, this.offsetY);
                this.ctx.stroke();
                
                // Y-Achse
                this.ctx.beginPath();
                this.ctx.moveTo(this.offsetX, 0);
                this.ctx.lineTo(this.offsetX, this.canvas.height);
                this.ctx.stroke();
            }
            
            drawFunction(mathEngine, func, playerX) {
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 10;
                
                this.ctx.beginPath();
                let started = false;
                
                for (let screenX = 0; screenX < this.canvas.width; screenX += 2) {
                    const worldX = (screenX - this.offsetX) / this.scale;
                    const y = mathEngine.safeEvaluate(func, worldX);
                    
                    if (y !== null && Math.abs(y) < 10) {
                        const screenPos = this.worldToScreen(worldX, y);
                        
                        if (!started) {
                            this.ctx.moveTo(screenPos.x, screenPos.y);
                            started = true;
                        } else {
                            this.ctx.lineTo(screenPos.x, screenPos.y);
                        }
                    } else {
                        started = false;
                    }
                }
                
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }
            
            drawPoles(poles) {
                poles.forEach(pole => {
                    const screenPos = this.worldToScreen(pole, 0);
                    
                    // Energiewand-Effekt
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.shadowBlur = 20;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                    
                    // Pulsierender Effekt
                    const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    this.ctx.shadowBlur = 10 + pulse * 20;
                    this.ctx.stroke();
                    
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawAsymptotes(asymptotes) {
                // Horizontale Asymptote
                if (asymptotes.horizontal !== null) {
                    const screenY = this.offsetY - asymptotes.horizontal * this.scale;
                    
                    this.ctx.strokeStyle = '#ff00ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = '#ff00ff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([10, 5]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                }
                
                // Schiefe Asymptote
                if (asymptotes.oblique) {
                    this.ctx.strokeStyle = '#ff00ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = '#ff00ff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([10, 5]);
                    
                    this.ctx.beginPath();
                    for (let screenX = 0; screenX < this.canvas.width; screenX += 10) {
                        const worldX = (screenX - this.offsetX) / this.scale;
                        const y = asymptotes.oblique.slope * worldX + asymptotes.oblique.intercept;
                        const screenPos = this.worldToScreen(worldX, y);
                        
                        if (screenX === 0) {
                            this.ctx.moveTo(screenPos.x, screenPos.y);
                        } else {
                            this.ctx.lineTo(screenPos.x, screenPos.y);
                        }
                    }
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                }
            }
            
            drawDiscontinuities(discontinuities) {
                discontinuities.forEach(disc => {
                    const screenPos = this.worldToScreen(disc, 0);
                    
                    // Sprungmarkierung
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.shadowColor = '#ffff00';
                    this.ctx.shadowBlur = 10;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, this.offsetY, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, this.offsetY, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.shadowBlur = 0;
                });
            }
            
            // Neue Visualisierungen f√ºr erweiterte Level
            drawTimeWarpZones(timeWarp) {
                if (!timeWarp) return;
                
                timeWarp.zones.forEach(zone => {
                    const screenPos = this.worldToScreen(zone, 0);
                    
                    // Zeitlupe-Zone als gr√ºne, pulsierende Kreise
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowColor = '#00ff00';
                    this.ctx.shadowBlur = 15;
                    
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    this.ctx.globalAlpha = pulse;
                    
                    for (let i = 0; i < 3; i++) {
                        const radius = 20 + i * 15;
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x, this.offsetY, radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawGravityZones(gravityZones) {
                if (!gravityZones) return;
                
                // Linke Gravitationszone
                if (gravityZones.left) {
                    const screenPos = this.worldToScreen(gravityZones.left.x, 0);
                    this.drawGravityZone(screenPos, gravityZones.left.strength, '#ff0080');
                }
                
                // Rechte Gravitationszone
                if (gravityZones.right) {
                    const screenPos = this.worldToScreen(gravityZones.right.x, 0);
                    this.drawGravityZone(screenPos, gravityZones.right.strength, '#8000ff');
                }
            }
            
            drawGravityZone(screenPos, strength, color) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = 20;
                
                // Gravitationslinien
                const lineCount = Math.abs(Math.floor(strength * 5));
                const lineLength = 30;
                
                for (let i = 0; i < lineCount; i++) {
                    const x = screenPos.x + (i - lineCount/2) * 8;
                    const y = this.offsetY;
                    
                    this.ctx.beginPath();
                    if (strength > 0) {
                        // Schwerkraft nach unten
                        this.ctx.moveTo(x, y - lineLength);
                        this.ctx.lineTo(x, y + lineLength);
                    } else {
                        // Schwerkraft nach oben
                        this.ctx.moveTo(x, y + lineLength);
                        this.ctx.lineTo(x, y - lineLength);
                    }
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
            }
            
            drawMultiPath(multiPath) {
                if (!multiPath) return;
                
                multiPath.paths.forEach((path, index) => {
                    const startPos = this.worldToScreen(path.start, 0);
                    const endPos = this.worldToScreen(path.end, 0);
                    
                    // Pfad-Markierung
                    this.ctx.strokeStyle = path.color;
                    this.ctx.lineWidth = 6;
                    this.ctx.shadowColor = path.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([15, 10]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startPos.x, this.offsetY);
                    this.ctx.lineTo(endPos.x, this.offsetY);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                    
                    // Pfad-Nummer
                    this.ctx.fillStyle = path.color;
                    this.ctx.font = 'bold 16px Orbitron';
                    this.ctx.textAlign = 'center';
                    const midX = (startPos.x + endPos.x) / 2;
                    this.ctx.fillText(`Pfad ${index + 1}`, midX, this.offsetY - 25);
                });
            }
            
            // Perfect Timing Rendering
            drawPerfectTimingCircle(circle) {
                const screenPos = this.worldToScreen(circle.x, circle.y);
                
                // √Ñu√üerer Kreis mit Glow-Effekt
                this.ctx.strokeStyle = circle.color;
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = circle.color;
                this.ctx.shadowBlur = 30;
                
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x, screenPos.y, circle.radius * this.scale, 0, Math.PI * 2);
                this.ctx.stroke();
                
                // Innerer pulsierender Kreis
                const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
                this.ctx.globalAlpha = pulse;
                this.ctx.strokeStyle = '#ffffff';
                this.ctx.lineWidth = 2;
                this.ctx.shadowBlur = 20;
                
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x, screenPos.y, (circle.radius - 10) * this.scale, 0, Math.PI * 2);
                this.ctx.stroke();
                
                this.ctx.globalAlpha = 1;
                this.ctx.shadowBlur = 0;
            }
            
            drawScreenFlashEffects(effects) {
                effects.forEach(effect => {
                    const screenPos = this.worldToScreen(effect.x, effect.y);
                    const alpha = effect.timer / effect.duration;
                    
                    this.ctx.globalAlpha = alpha;
                    this.ctx.fillStyle = effect.color;
                    this.ctx.shadowColor = effect.color;
                    this.ctx.shadowBlur = 50;
                    
                    switch (effect.type) {
                        case 'circle':
                            this.ctx.beginPath();
                            this.ctx.arc(screenPos.x, screenPos.y, 100 * alpha, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                            
                        case 'star':
                            this.drawStar(screenPos.x, screenPos.y, 80 * alpha);
                            break;
                            
                        case 'wave':
                            this.drawWave(screenPos.x, screenPos.y, 120 * alpha);
                            break;
                            
                        case 'explosion':
                            this.drawExplosion(screenPos.x, screenPos.y, 90 * alpha);
                            break;
                    }
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawStar(x, y, size) {
                this.ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
                    const px = x + Math.cos(angle) * size;
                    const py = y + Math.sin(angle) * size;
                    
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                    
                    const innerAngle = angle + Math.PI / 5;
                    const innerSize = size * 0.4;
                    const ix = x + Math.cos(innerAngle) * innerSize;
                    const iy = y + Math.sin(innerAngle) * innerSize;
                    this.ctx.lineTo(ix, iy);
                }
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawWave(x, y, size) {
                this.ctx.beginPath();
                for (let i = 0; i < 360; i += 10) {
                    const angle = (i * Math.PI) / 180;
                    const waveSize = size + Math.sin(angle * 3) * 20;
                    const px = x + Math.cos(angle) * waveSize;
                    const py = y + Math.sin(angle) * waveSize;
                    
                    if (i === 0) this.ctx.moveTo(px, py);
                    else this.ctx.lineTo(px, py);
                }
                this.ctx.closePath();
                this.ctx.fill();
            }
            
            drawExplosion(x, y, size) {
                // Explosions-Form mit mehreren Kreisen
                for (let i = 0; i < 3; i++) {
                    const explosionSize = size * (0.5 + i * 0.3);
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, explosionSize, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            // Zus√§tzliche Teleporter-Markierungen f√ºr Level 3
            drawTeleporterMarkers(discontinuities) {
                discontinuities.forEach(disc => {
                    const center = this.worldToScreen(disc, 0);
                    const ctx = this.ctx;
                    const rings = [22, 28, 34];
                    rings.forEach((r, i) => {
                        ctx.strokeStyle = i % 2 === 0 ? '#ff00ff' : '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = ctx.strokeStyle;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(center.x, this.offsetY, r, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                    ctx.shadowBlur = 0;
                });
            }
            
            drawPlayer(player) {
                const screenPos = this.worldToScreen(player.x, player.y);
                
                // Trail zeichnen
                if (player.trail.length > 1) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < player.trail.length; i++) {
                        const trailPos = this.worldToScreen(player.trail[i].x, player.trail[i].y);
                        if (i === 0) {
                            this.ctx.moveTo(trailPos.x, trailPos.y);
                        } else {
                            this.ctx.lineTo(trailPos.x, trailPos.y);
                        }
                    }
                    this.ctx.stroke();
                }
                
                // Spieler zeichnen
                let playerColor = player.boostTime > 0 ? '#ffff00' : '#00ffff';
                let playerShadow = player.boostTime > 0 ? '#ffff00' : '#00ffff';
                
                // Chaos-Modus: Zuf√§llige Farbe
                if (player.chaosColor) {
                    playerColor = player.chaosColor;
                    playerShadow = player.chaosColor;
                }
                
                this.ctx.fillStyle = playerColor;
                this.ctx.shadowColor = playerShadow;
                this.ctx.shadowBlur = player.boostTime > 0 ? 25 : 15;
                
                // Chaos-Modus: Gr√∂√üen√§nderung
                const radius = player.radius * (player.chaosSize || 1);
                
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Sprung-Indikator
                if (player.jumping) {
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, screenPos.y, player.radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
            }
            
            drawParticles(particles) {
                particles.forEach(particle => {
                    const screenPos = this.worldToScreen(particle.x, particle.y);
                    
                    this.ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, screenPos.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
        }
        
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.mathEngine = new MathEngine();
                this.renderer = new Renderer(this.canvas, this.ctx);
                
                // Hintergrund-Effekte initialisieren
                this.backgroundCanvas = document.getElementById('backgroundCanvas');
                this.backgroundEffects = new BackgroundEffects(this.backgroundCanvas);
                
                this.player = new Player(-5, 0);
                this.currentLevel = 1;
                this.score = 0;
                this.lives = 3;
                this.gameRunning = true;
                this.particles = [];
                this.jumpBuffer = 0; // kurzzeitiger Sprungpuffer f√ºr forgiving timing
                this.levelStartCooldown = 0; // Frames bis Levelabschluss erlaubt ist
                this.teleportCooldown = 0; // Cooldown f√ºr Teleporter (Frames)
                // Jump-Forward-Dash Parameter
                this.jumpDashFrames = 24; // wie lange zus√§tzlicher Vorschub wirkt
                this.jumpDashMultiplier = 3.0; // wie stark der Vorschub ist
                
                // Neue Level-Mechaniken
                this.timeWarpActive = false;
                this.timeWarpFactor = 1;
                this.gravityShift = 0;
                this.chaosMode = false;
                this.chaosTimer = 0;
                this.currentPath = 0; // F√ºr Multi-Path Level
                
                // Pause-Funktionalit√§t
                this.isPaused = false;
                this.pauseMenuVisible = false;
                
                // Perfect Timing System
                this.perfectTimingActive = false;
                this.perfectTimingCircle = null;
                this.perfectTimingTimer = 0;
                this.perfectTimingCooldown = 0;
                this.screenFlashEffects = [];
                
                this.keys = {};
                this.currentFunction = null;
                
                this.loadLevel(this.currentLevel);
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.startJump();
                        this.jumpBuffer = 12; // wenige Frames Puffer aktivieren
                    }
                    
                    if (e.code === 'KeyR') {
                        this.restart();
                    }
                    
                    // Multi-Path Level 8: Pfad-Wechsel
                    if (e.code === 'Digit1' || e.code === 'Digit2') {
                        if (this.currentLevel === 8 && this.currentFunction.multiPath) {
                            const pathIndex = parseInt(e.code.replace('Digit', '')) - 1;
                            if (pathIndex < this.currentFunction.multiPath.paths.length) {
                                this.currentPath = pathIndex;
                                this.switchToPath(pathIndex);
                            }
                        }
                    }
                    
                    // Pause-Taste
                    if (e.code === 'Escape') {
                        this.togglePause();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            // Teleportiere den Spieler in Level 3 an der L√ºcke auf die rechte Seite
            tryTeleportAtDiscontinuity(prevX) {
                if (this.currentLevel !== 3) return;
                if (this.teleportCooldown > 0) return;
                if (this.player.jumping) return;
                const discs = this.currentFunction.discontinuities || [];
                for (let disc of discs) {
                    const nearNow = Math.abs(this.player.x - disc) < 0.35; // wie Kollision
                    const crossed = (Math.min(prevX, this.player.x) - 0.02) <= disc && (Math.max(prevX, this.player.x) + 0.02) >= disc;
                    if (nearNow || crossed) {
                        let newX = disc + 0.7;
                        let newY = this.mathEngine.safeEvaluate(this.currentFunction, newX);
                        if (newY === null) {
                            const step = 0.1;
                            for (let i = 1; i <= 10 && newY === null; i++) {
                                newX = disc + 0.6 + i * step;
                                newY = this.mathEngine.safeEvaluate(this.currentFunction, newX);
                            }
                        }
                        this.player.x = newX;
                        if (newY !== null) this.player.y = newY;
                        this.teleportCooldown = 18; // ~0.3s
                        // kleines Feedback
                        this.addScore(100);
                        if (this.createJumpParticles) this.createJumpParticles();
                        break;
                    }
                }
            }
            
            // Berechne ein sinnvolles Landeziel rechts von der aktuellen Position
            computeJumpTargetX() {
                const x0 = this.player.x;
                const maxReach = 2.2; // maximale horizontale Reichweite eines Sprungs
                let target = x0 + 1.2; // Default-Landeplatz
                // Suche n√§chstgelegenes Hindernis rechts (Pol oder L√ºcke)
                const candidates = [
                    ...(this.currentFunction.poles || []),
                    ...(this.currentFunction.discontinuities || [])
                ].filter(x => x > x0 && x - x0 < maxReach).sort((a,b)=>a-b);
                if (candidates.length > 0) {
                    const obst = candidates[0];
                    target = obst + 0.6; // etwas hinter dem Hindernis landen
                }
                return target;
            }

            // Starte einen deterministischen Bogen-Sprung zur anderen Kurve
            startJump() {
                if (this.player.jumping) return;
                let targetX = this.computeJumpTargetX();
                let targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX);
                // Falls direkt auf Pol/L√ºcke, etwas weiter springen
                if (targetY === null) {
                    const delta = 0.2;
                    for (let i = 1; i <= 5 && targetY === null; i++) {
                        targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX + i * delta);
                        if (targetY !== null) { targetX += i * delta; break; }
                    }
                }
                if (targetY === null) {
                    // Fallback: kleine Verschiebung oberhalb der aktuellen y
                    targetY = (this.player.y + 0.5);
                }
                
                // Perfect Timing bei jedem Sprung aktivieren
                this.activatePerfectTimingForJump(targetX, targetY);
                
                this.player.startArcJump(targetX, targetY);
            }
            
            loadLevel(level) {
                this.currentFunction = this.mathEngine.parseFunction(level);
                // Basisgeschwindigkeit pro Level (Level 1 langsam, pro Level schneller)
                this.baseSpeed = 0.003 + (level - 1) * 0.006;
                if (level === 3) {
                    // Level 3 etwas langsamer, um Teleporter/Sprung zu √ºben
                    this.baseSpeed *= 0.8;
                }
                
                // Spezielle Level-Mechaniken
                if (level === 6) {
                    // Level 6: Zeitlupe in bestimmten Zonen
                    this.timeWarpActive = true;
                } else {
                    this.timeWarpActive = false;
                }
                
                if (level === 7) {
                    // Level 7: Gravitationswechsel
                    this.gravityShift = 0;
                } else {
                    this.gravityShift = 0;
                }
                
                if (level === 8) {
                    // Level 8: Multi-Path
                    this.currentPath = 0;
                }
                
                if (level === 9) {
                    // Level 9: Inverser Boost
                    // Wird in der Kollisionserkennung behandelt
                }
                
                if (level === 10) {
                    // Level 10: Chaos-Modus
                    this.chaosMode = true;
                    this.chaosTimer = 0;
                } else {
                    this.chaosMode = false;
                }
                // Spawn-Position je nach Level-Schwierigkeit
                this.player.x = this.getSpawnPosition(level);
                this.player.y = this.mathEngine.safeEvaluate(this.currentFunction, this.player.x) || 0;
                // Spielerzustand vollst√§ndig zur√ºcksetzen
                this.player.trail = [];
                this.player.jumping = false;
                this.player.jumpTime = 0;
                this.player.boostTime = 0;
                // Arc-Parameter zur√ºcksetzen
                this.player.jumpStartX = this.player.x;
                this.player.jumpStartY = this.player.y;
                this.player.jumpTargetX = this.player.x;
                this.player.jumpTargetY = this.player.y;
                // Eingaben und Buffer/Cooldown zur√ºcksetzen
                this.keys = {};
                this.jumpBuffer = 0;
                this.levelStartCooldown = 30; // ~0.5s bei 60fps
                this.teleportCooldown = 0;
                
                // UI aktualisieren
                document.getElementById('level').textContent = `Level: ${level}`;
                
                // Hintergrund und Effekte f√ºr das Level setzen
                this.setLevelBackground(level);
                
                const functionTexts = {
                    1: 'f(x) = 1/(x-2)',
                    2: 'f(x) = 1/((x-1)(x+1))',
                    3: 'f(x) = (x-1)/((x-1)(x-2)) ‚Äî Teleporter an der gelben L√ºcke! Springe f√ºr Bonus.',
                    4: 'f(x) = (x¬≤+1)/(x-1)',
                    5: 'f(x) = (x¬≤-4)/((x-1)(x+2)(x-3))',
                    6: 'f(x) = (x¬≥-2x)/(x¬≤-4) ‚Äî Zeitlupe in gr√ºnen Zonen!',
                    7: 'f(x) = 1/(x¬≤-1) ‚Äî Gravitationswechsel! Schwerkraft √§ndert sich!',
                    8: 'f(x) = (x¬≤-1)/(x-1) ‚Äî Multi-Path! W√§hle deinen Weg!',
                    9: 'f(x) = (x¬≥+1)/(x¬≤-1) ‚Äî Inverser Boost! Asymptoten verlangsamen!',
                    10: 'f(x) = (x‚Å¥-5x¬≤+4)/(x¬≥-2x¬≤-x+2) ‚Äî Chaos-Modus! Alles ist m√∂glich!'
                };
                
                document.getElementById('function').textContent = functionTexts[level] || functionTexts[1];
            }
            
            update() {
                if (!this.gameRunning || this.isPaused) return;
                const prevX = this.player.x;
                
                // Automatisches Fahren nach rechts (geschwindigkeitsabh√§ngig pro Level)
                this.player.vx = this.baseSpeed; // Grundgeschwindigkeit pro Level
                
                // Manuelle Geschwindigkeitskontrolle (optional)
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    this.player.vx *= 0.5; // Verlangsamen
                }
                if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    this.player.vx *= 1.5; // Beschleunigen
                }
                
                // Boost-Geschwindigkeit
                if (this.player.boostTime > 0) {
                    if (this.currentLevel === 9 && this.currentFunction.inverseBoost) {
                        // Level 9: Inverser Boost - verlangsamt
                        this.player.vx *= 0.3;
                    } else {
                        // Normaler Boost
                        this.player.vx *= 2;
                    }
                }
                
                // Level 6: Zeitlupe in bestimmten Zonen
                if (this.timeWarpActive && this.currentFunction.timeWarp) {
                    const inTimeWarpZone = this.currentFunction.timeWarp.zones.some(zone => 
                        Math.abs(this.player.x - zone) < 1
                    );
                    if (inTimeWarpZone) {
                        this.timeWarpFactor = this.currentFunction.timeWarp.factor;
                        this.player.vx *= this.timeWarpFactor;
                    } else {
                        this.timeWarpFactor = 1;
                    }
                }
                
                // Level 7: Gravitationswechsel
                if (this.currentLevel === 7 && this.currentFunction.gravityZones) {
                    if (this.player.x < this.currentFunction.gravityZones.left.x) {
                        this.gravityShift = this.currentFunction.gravityZones.left.strength;
                    } else if (this.player.x > this.currentFunction.gravityZones.right.x) {
                        this.gravityShift = this.currentFunction.gravityZones.right.strength;
                    } else {
                        this.gravityShift = 0;
                    }
                }
                
                // Level 10: Chaos-Modus
                if (this.chaosMode) {
                    this.chaosTimer++;
                    if (this.chaosTimer % 120 === 0) { // Alle 2 Sekunden
                        this.triggerRandomChaosEffect();
                    }
                }
                
                // Perfect Timing System
                this.updatePerfectTiming();
                
                // W√§hrend des Arc-Sprungs steuert der Bogen x/y direkt ‚Äì kein Air-Assist n√∂tig
                
                this.player.update(this.mathEngine, this.currentFunction);

                // Sprungpuffer herunterz√§hlen
                if (this.jumpBuffer > 0) this.jumpBuffer--;
                if (this.levelStartCooldown > 0) this.levelStartCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;

                // Level 3: Teleporter an Definitionsl√ºcke
                this.tryTeleportAtDiscontinuity(prevX);

                // Kollisionserkennung
                const collision = this.player.checkCollisions(this.mathEngine, this.currentFunction, this);
                
                if (collision === 'pole') {
                    this.loseLife();
                } else if (collision === 'boost') {
                    this.addScore(100); // Score nur durch Boost
                    this.createBoostParticles();
                } else if (collision === 'discontinuity_success') {
                    this.addScore(200); // Score nur durch erfolgreichen Sprung
                    this.createJumpParticles();
                } else if (collision === 'discontinuity_fail') {
                    this.loseLife(); // Bestrafung f√ºr vergessenen Sprung
                }
                
                // Perfect Timing Kollisionserkennung
                this.checkPerfectTimingHit();
                
                // Perfect Timing bei Sprung-Ende √ºberpr√ºfen
                if (this.player.jumping && this.perfectTimingActive) {
                    this.checkJumpPerfectTiming();
                }
                
                // Kein automatischer Score mehr!
                
                // Level-Completion (Spieler erreicht x = 5) ‚Äì erst nach Cooldown
                if (this.levelStartCooldown === 0 && this.player.x > 5) {
                    this.completeLevel();
                }
                
                // Partikel aktualisieren
                this.updateParticles();
                
                // Kamera folgt Spieler
                this.renderer.offsetX = this.canvas.width / 2 - this.player.x * this.renderer.scale;
            }
            
            render() {
                this.renderer.clear();
                this.renderer.drawGrid();
                this.renderer.drawAsymptotes(this.currentFunction.asymptotes);
                this.renderer.drawFunction(this.mathEngine, this.currentFunction, this.player.x);
                this.renderer.drawPoles(this.currentFunction.poles);
                this.renderer.drawDiscontinuities(this.currentFunction.discontinuities);
                
                // Level-spezifische Visualisierungen
                if (this.currentLevel === 3) {
                    this.renderer.drawTeleporterMarkers(this.currentFunction.discontinuities);
                }
                if (this.currentLevel === 6 && this.currentFunction.timeWarp) {
                    this.renderer.drawTimeWarpZones(this.currentFunction.timeWarp);
                }
                if (this.currentLevel === 7 && this.currentFunction.gravityZones) {
                    this.renderer.drawGravityZones(this.currentFunction.gravityZones);
                }
                if (this.currentLevel === 8 && this.currentFunction.multiPath) {
                    this.renderer.drawMultiPath(this.currentFunction.multiPath);
                }
                
                this.renderer.drawParticles(this.particles);
                this.renderer.drawPlayer(this.player);
                
                // Perfect Timing Kreis zeichnen
                if (this.perfectTimingActive && this.perfectTimingCircle) {
                    this.renderer.drawPerfectTimingCircle(this.perfectTimingCircle);
                }
                
                // Screen Flash Effekte zeichnen
                this.renderer.drawScreenFlashEffects(this.screenFlashEffects);
            }
            
            gameLoop() {
                this.update();
                this.render();
                
                // Hintergrund-Effekte aktualisieren und rendern
                if (this.backgroundEffects) {
                    this.backgroundEffects.update();
                    this.backgroundEffects.render();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            addScore(points) {
                this.score += points;
                document.getElementById('score').textContent = `Score: ${this.score}`;
            }
            
            loseLife() {
                this.lives--;
                document.getElementById('lives').textContent = `Lives: ${this.lives}`;
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Respawn an der levelabh√§ngigen Position
                    this.player.x = this.getSpawnPosition(this.currentLevel);
                    this.player.y = this.mathEngine.safeEvaluate(this.currentFunction, this.player.x) || 0;
                    this.player.trail = [];
                    this.player.jumping = false;
                    this.player.jumpTime = 0;
                    this.player.boostTime = 0;
                    // Arc-Parameter zur√ºcksetzen
                    this.player.jumpStartX = this.player.x;
                    this.player.jumpStartY = this.player.y;
                    this.player.jumpTargetX = this.player.x;
                    this.player.jumpTargetY = this.player.y;
                }
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            completeLevel() {
                const bonus = this.lives * 500;
                this.addScore(bonus);
                
                document.getElementById('levelBonus').textContent = bonus;
                document.getElementById('levelComplete').style.display = 'block';
                this.gameRunning = false;
            }
            
            nextLevel() {
                this.currentLevel++;
                if (this.currentLevel > 10) {
                    alert('Herzlichen Gl√ºckwunsch! Du hast alle 10 Level geschafft! Du bist ein Asymptoten-Meister! üéâ');
                    this.restart();
                    return;
                }
                
                this.loadLevel(this.currentLevel);
                document.getElementById('levelComplete').style.display = 'none';
                this.gameRunning = true;
            }
            
            restart() {
                this.currentLevel = 1;
                this.score = 0;
                this.lives = 3;
                this.gameRunning = true;
                this.particles = [];
                
                // Alle Level-Mechaniken zur√ºcksetzen
                this.timeWarpActive = false;
                this.timeWarpFactor = 1;
                this.gravityShift = 0;
                this.chaosMode = false;
                this.chaosTimer = 0;
                this.currentPath = 0;
                
                // Hintergrund zur√ºcksetzen
                document.body.className = '';
                
                this.loadLevel(this.currentLevel);
                
                document.getElementById('score').textContent = `Score: ${this.score}`;
                document.getElementById('lives').textContent = `Lives: ${this.lives}`;
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('levelComplete').style.display = 'none';
            }
            
            createBoostParticles() {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.5,
                        y: this.player.y + (Math.random() - 0.5) * 0.5,
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: (Math.random() - 0.5) * 0.1,
                        size: Math.random() * 3 + 1,
                        alpha: 1,
                        color: { r: 255, g: 255, b: 0 },
                        life: 60
                    });
                }
            }
            
            createJumpParticles() {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.3,
                        y: this.player.y + (Math.random() - 0.5) * 0.3,
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: (Math.random() - 0.5) * 0.15,
                        size: Math.random() * 4 + 2,
                        alpha: 1,
                        color: { r: 0, g: 255, b: 255 },
                        life: 45
                    });
                }
            }
            
            updateParticles() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.alpha = particle.life / 60;
                    
                    return particle.life > 0;
                });
            }
            
            triggerRandomChaosEffect() {
                if (!this.chaosMode) return;
                
                const effects = this.currentFunction.chaosEffects || [];
                if (effects.length === 0) return;
                
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                
                switch (randomEffect) {
                    case 'timeWarp':
                        this.timeWarpFactor = Math.random() * 0.5 + 0.3; // 0.3 bis 0.8
                        this.player.vx *= this.timeWarpFactor;
                        this.createTimeWarpParticles();
                        break;
                    case 'gravityShift':
                        this.gravityShift = (Math.random() - 0.5) * 2; // -1 bis 1
                        this.createGravityParticles();
                        break;
                    case 'colorShift':
                        // Spielerfarbe √§ndern
                        this.player.chaosColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        setTimeout(() => { this.player.chaosColor = null; }, 3000);
                        break;
                    case 'sizeShift':
                        // Spielergr√∂√üe √§ndern
                        this.player.chaosSize = Math.random() * 1.5 + 0.5; // 0.5 bis 2.0
                        setTimeout(() => { this.player.chaosSize = 1; }, 3000);
                        break;
                }
            }
            
            createTimeWarpParticles() {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.8,
                        y: this.player.y + (Math.random() - 0.5) * 0.8,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        size: Math.random() * 4 + 2,
                        alpha: 1,
                        color: { r: 0, g: 255, b: 0 },
                        life: 90
                    });
                }
            }
            
            createGravityParticles() {
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.6,
                        y: this.player.y + (Math.random() - 0.5) * 0.6,
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: this.gravityShift * 0.1,
                        size: Math.random() * 3 + 1,
                        alpha: 1,
                        color: { r: 255, g: 0, b: 255 },
                        life: 75
                    });
                }
            }
            
            switchToPath(pathIndex) {
                if (this.currentLevel !== 8 || !this.currentFunction.multiPath) return;
                
                const path = this.currentFunction.multiPath.paths[pathIndex];
                if (!path) return;
                
                // Spieler auf den gew√§hlten Pfad teleportieren
                const targetX = (path.start + path.end) / 2;
                const targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX);
                
                if (targetY !== null) {
                    this.player.x = targetX;
                    this.player.y = targetY;
                    
                    // Partikel-Effekt f√ºr Pfad-Wechsel
                    this.createPathSwitchParticles();
                    
                    // Score-Bonus f√ºr Pfad-Wechsel
                    this.addScore(150);
                }
            }
            
            createPathSwitchParticles() {
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.8,
                        y: this.player.y + (Math.random() - 0.5) * 0.8,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        size: Math.random() * 5 + 3,
                        alpha: 1,
                        color: { r: 255, g: 255, b: 0 },
                        life: 60
                    });
                }
            }
            
            // Hilfsfunktion f√ºr Spawn-Position
            getSpawnPosition(level) {
                if (level >= 1 && level <= 3) return -5;      // Einfache Level
                if (level >= 4 && level <= 6) return -12;     // Mittlere Schwierigkeit - viel weiter links
                if (level >= 7 && level <= 9) return -18;     // Hohe Schwierigkeit - noch weiter links
                if (level === 10) return -25;                 // Chaos-Modus - am weitesten links
                return -5; // Fallback
            }
            
            // Pause-Funktionalit√§t
            togglePause() {
                if (this.isPaused) {
                    this.resumeGame();
                } else {
                    this.pauseGame();
                }
            }
            
            pauseGame() {
                this.isPaused = true;
                this.pauseMenuVisible = true;
                document.getElementById('pauseMenu').style.display = 'block';
            }
            
            resumeGame() {
                this.isPaused = false;
                this.pauseMenuVisible = false;
                document.getElementById('pauseMenu').style.display = 'none';
            }
            
            showMainMenu() {
                this.pauseMenuVisible = false;
                document.getElementById('pauseMenu').style.display = 'none';
                this.restart();
            }
            
            setLevelBackground(level) {
                // Body-Klasse f√ºr CSS-Hintergrund √§ndern
                document.body.className = `level-${level}`;
                
                // BackgroundEffects-Level setzen
                if (this.backgroundEffects) {
                    this.backgroundEffects.setLevel(level);
                }
            }
            
            // Perfect Timing System - Bei jedem Sprung
            updatePerfectTiming() {
                // Perfect Timing aktualisieren
                if (this.perfectTimingActive) {
                    this.perfectTimingTimer++;
                    
                    // Perfect Timing beenden nach 2 Sekunden
                    if (this.perfectTimingTimer > 120) {
                        this.deactivatePerfectTiming();
                        return;
                    }
                    
                    // Kreis schrumpfen lassen - schneller f√ºr bessere Timing-Herausforderung
                    if (this.perfectTimingCircle) {
                        this.perfectTimingCircle.radius = Math.max(8, 80 - this.perfectTimingTimer * 0.6);
                    }
                }
                
                // Screen Flash Effekte aktualisieren
                this.updateScreenFlashEffects();
            }
            
            activatePerfectTiming() {
                this.perfectTimingActive = true;
                this.perfectTimingTimer = 0;
                
                // Kreis um den Spieler erstellen
                this.perfectTimingCircle = {
                    x: this.player.x,
                    y: this.player.y,
                    radius: 100,
                    color: '#ff00ff'
                };
                
                // UI-Hinweis anzeigen
                this.showPerfectTimingHint();
            }
            
            activatePerfectTimingForJump(targetX, targetY) {
                this.perfectTimingActive = true;
                this.perfectTimingTimer = 0;
                
                // Kreis um den Spieler erstellen, der den idealen Sprung-Moment markiert
                this.perfectTimingCircle = {
                    x: this.player.x,
                    y: this.player.y,
                    radius: 80, // Etwas kleiner f√ºr bessere Pr√§zision
                    color: '#00ffff', // Cyan f√ºr Sprung-Perfect Timing
                    targetX: targetX,
                    targetY: targetY
                };
                
                // UI-Hinweis f√ºr Sprung-Perfect Timing
                this.showJumpPerfectTimingHint();
            }
            
            deactivatePerfectTiming() {
                this.perfectTimingActive = false;
                this.perfectTimingCircle = null;
                this.perfectTimingCooldown = 300; // 5 Sekunden Cooldown
            }
            
            checkPerfectTimingHit() {
                if (!this.perfectTimingActive || !this.perfectTimingCircle) return false;
                
                const distance = Math.sqrt(
                    Math.pow(this.player.x - this.perfectTimingCircle.x, 2) + 
                    Math.pow(this.player.y - this.perfectTimingCircle.y, 2)
                );
                
                // Perfekter Treffer wenn der Kreis den Spieler ber√ºhrt
                if (distance <= this.perfectTimingCircle.radius) {
                    this.triggerPerfectTiming();
                    return true;
                }
                
                return false;
            }
            
            checkJumpPerfectTiming() {
                if (!this.perfectTimingActive || !this.perfectTimingCircle) return false;
                
                // √úberpr√ºfe ob der Spieler den idealen Sprung-Moment getroffen hat
                const jumpProgress = this.player.jumpTime / this.player.jumpDuration;
                
                // Perfekter Moment ist in der Mitte des Sprungs (bei 50%)
                if (Math.abs(jumpProgress - 0.5) < 0.1) {
                    this.triggerJumpPerfectTiming();
                    return true;
                }
                
                return false;
            }
            
            triggerPerfectTiming() {
                // Massive Belohnungen
                this.addScore(1000); // 1000 Punkte Bonus
                this.player.boostTime = 120; // 2 Sekunden Boost
                
                // Bildschirm-Aufleuchtung
                this.createScreenFlashEffects();
                
                // Partikel-Explosion
                this.createPerfectTimingParticles();
                
                // Perfect Timing beenden
                this.deactivatePerfectTiming();
                
                // UI-Feedback
                this.showPerfectTimingSuccess();
            }
            
            triggerJumpPerfectTiming() {
                // Belohnungen f√ºr perfekten Sprung
                this.addScore(500); // 500 Punkte f√ºr perfekten Sprung
                this.player.boostTime = 60; // 1 Sekunde Boost
                
                // Bildschirm-Aufleuchtung
                this.createJumpScreenFlashEffects();
                
                // Partikel-Explosion
                this.createJumpPerfectTimingParticles();
                
                // Perfect Timing beenden
                this.deactivatePerfectTiming();
                
                // UI-Feedback
                this.showJumpPerfectTimingSuccess();
            }
            
            createScreenFlashEffects() {
                // Verschiedene Flash-Effekte
                const effects = [
                    { type: 'circle', color: '#ff00ff', duration: 60 },
                    { type: 'star', color: '#ffff00', duration: 45 },
                    { type: 'wave', color: '#00ffff', duration: 90 },
                    { type: 'explosion', color: '#ff0080', duration: 75 }
                ];
                
                effects.forEach(effect => {
                    this.screenFlashEffects.push({
                        ...effect,
                        timer: effect.duration,
                        x: this.player.x,
                        y: this.player.y
                    });
                });
            }
            
            updateScreenFlashEffects() {
                this.screenFlashEffects = this.screenFlashEffects.filter(effect => {
                    effect.timer--;
                    return effect.timer > 0;
                });
            }
            
            createPerfectTimingParticles() {
                // Massive Partikel-Explosion
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 2,
                        y: this.player.y + (Math.random() - 0.5) * 2,
                        vx: (Math.random() - 0.5) * 0.8,
                        vy: (Math.random() - 0.5) * 0.8,
                        size: Math.random() * 8 + 4,
                        alpha: 1,
                        color: this.getRandomPerfectTimingColor(),
                        life: 120
                    });
                }
            }
            
            createJumpScreenFlashEffects() {
                // Spezielle Flash-Effekte f√ºr Sprung-Perfect Timing
                const effects = [
                    { type: 'circle', color: '#00ffff', duration: 40 }, // Cyan f√ºr Spr√ºnge
                    { type: 'star', color: '#00ff00', duration: 30 },   // Gr√ºn f√ºr Erfolg
                    { type: 'wave', color: '#0080ff', duration: 60 }    // Blau f√ºr Bewegung
                ];
                
                effects.forEach(effect => {
                    this.screenFlashEffects.push({
                        ...effect,
                        timer: effect.duration,
                        x: this.player.x,
                        y: this.player.y
                    });
                });
            }
            
            createJumpPerfectTimingParticles() {
                // Partikel-Explosion f√ºr perfekten Sprung
                for (let i = 0; i < 30; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 1.5,
                        y: this.player.y + (Math.random() - 0.5) * 1.5,
                        vx: (Math.random() - 0.5) * 1.0,
                        vy: (Math.random() - 0.5) * 1.0,
                        size: Math.random() * 6 + 3,
                        alpha: 1,
                        color: this.getRandomJumpPerfectTimingColor(),
                        life: 90
                    });
                }
            }
            
            getRandomJumpPerfectTimingColor() {
                const colors = [
                    { r: 0, g: 255, b: 255 },   // Cyan
                    { r: 0, g: 255, b: 0 },     // Gr√ºn
                    { r: 0, g: 128, b: 255 },   // Blau
                    { r: 255, g: 255, b: 255 }  // Wei√ü
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            getRandomPerfectTimingColor() {
                const colors = [
                    { r: 255, g: 0, b: 255 },   // Magenta
                    { r: 255, g: 255, b: 0 },   // Gelb
                    { r: 0, g: 255, b: 255 },   // Cyan
                    { r: 255, g: 0, b: 127 },   // Rose
                    { r: 255, g: 255, b: 255 }  // Wei√ü
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }
            
            showPerfectTimingHint() {
                // Tempor√§rer UI-Hinweis
                const hint = document.createElement('div');
                hint.textContent = 'PERFECT TIMING!';
                hint.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #ff00ff;
                    font-size: 48px;
                    font-weight: bold;
                    text-shadow: 0 0 20px #ff00ff;
                    z-index: 1000;
                    pointer-events: none;
                `;
                document.body.appendChild(hint);
                
                // Nach 2 Sekunden entfernen
                setTimeout(() => {
                    if (hint.parentNode) {
                        hint.parentNode.removeChild(hint);
                    }
                }, 2000);
            }
            
            showPerfectTimingSuccess() {
                // Erfolgs-Animation
                const success = document.createElement('div');
                success.textContent = 'PERFECT! +1000';
                success.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #ffff00;
                    font-size: 36px;
                    font-weight: bold;
                    text-shadow: 0 0 15px #ffff00;
                    z-index: 1000;
                    pointer-events: none;
                `;
                document.body.appendChild(success);
                
                // Nach 3 Sekunden entfernen
                setTimeout(() => {
                    if (success.parentNode) {
                        success.parentNode.removeChild(success);
                    }
                }, 3000);
            }
            
            showJumpPerfectTimingHint() {
                // UI-Hinweis f√ºr Sprung-Perfect Timing
                const hint = document.createElement('div');
                hint.textContent = 'PERFECT TIMING!';
                hint.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #00ffff;
                    font-size: 36px;
                    font-weight: bold;
                    text-shadow: 0 0 20px #00ffff;
                    z-index: 1000;
                    pointer-events: none;
                `;
                document.body.appendChild(hint);
                
                // Nach 1.5 Sekunden entfernen (k√ºrzer f√ºr Spr√ºnge)
                setTimeout(() => {
                    if (hint.parentNode) {
                        hint.parentNode.removeChild(hint);
                    }
                }, 1500);
            }
            
            showJumpPerfectTimingSuccess() {
                // Erfolgs-Animation f√ºr perfekten Sprung
                const success = document.createElement('div');
                success.textContent = 'PERFECT JUMP! +500';
                success.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    color: #00ff00;
                    font-size: 32px;
                    font-weight: bold;
                    text-shadow: 0 0 15px #00ff00;
                    z-index: 1000;
                    pointer-events: none;
                `;
                document.body.appendChild(success);
                
                // Nach 2 Sekunden entfernen
                setTimeout(() => {
                    if (success.parentNode) {
                        success.parentNode.removeChild(success);
                    }
                }, 2000);
            }
        }
        
        // Spiel starten
        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>
