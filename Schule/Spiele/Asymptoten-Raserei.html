<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Asymptoten-Raserei</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            font-family: 'Orbitron', monospace;
            color: #00ffff;
            overflow: hidden;
            height: 100vh;
        }
        
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        #gameCanvas {
            border: 2px solid #00ffff;
            border-radius: 10px;
            box-shadow: 
                0 0 20px #00ffff,
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            background: radial-gradient(circle at center, #0a0a0a 0%, #000000 100%);
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }
        
        .ui-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #00ffff;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 0 10px #00ffff;
        }
        
        #score, #level, #lives {
            font-size: 18px;
            font-weight: 700;
            text-shadow: 0 0 10px #00ffff;
        }
        
        #function {
            font-size: 14px;
            color: #ff00ff;
            text-shadow: 0 0 5px #ff00ff;
            max-width: 300px;
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            color: #888;
        }
        
        #gameOver, #levelComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff00ff;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 0 30px #ff00ff;
            display: none;
        }
        
        #gameOver h2, #levelComplete h2 {
            color: #ff00ff;
            font-size: 24px;
            margin-bottom: 15px;
            text-shadow: 0 0 15px #ff00ff;
        }
        
        button {
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            border: none;
            color: #000;
            padding: 10px 20px;
            font-family: 'Orbitron', monospace;
            font-weight: 700;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: all 0.3s;
        }
        
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #00ffff;
        }
        
        .glow {
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { text-shadow: 0 0 5px #00ffff; }
            to { text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff; }
        }
        
        .pulse {
            animation: pulse 1s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div id="ui">
            <div class="ui-panel">
                <div id="score" class="glow">Score: 0</div>
                <div id="level">Level: 1</div>
                <div id="lives">Lives: 3</div>
            </div>
            <div class="ui-panel">
                <div id="function">f(x) = 1/(x-2)</div>
            </div>
        </div>
        
        <div id="controls">
            <p>‚Üê Bremsen | ‚Üí Beschleunigen | Leertaste: Sprung | R: Restart</p>
            <p style="font-size: 10px; margin-top: 5px;">üéØ Fahre automatisch! Springe √ºber gelbe L√ºcken, nutze pinke Asymptoten f√ºr Boosts!</p>
            <p style="font-size: 10px; margin-top: 5px;">üîß Level 8: 1/2 f√ºr Pfad-Wechsel | Level 10: Chaos-Effekte alle 2 Sekunden!</p>
        </div>
        
        <div id="gameOver">
            <h2>Game Over!</h2>
            <p>Score: <span id="finalScore">0</span></p>
            <button onclick="game.restart()">Nochmal spielen</button>
        </div>
        
        <div id="levelComplete">
            <h2>Level geschafft!</h2>
            <p>Bonus: <span id="levelBonus">0</span></p>
            <button onclick="game.nextLevel()">N√§chstes Level</button>
        </div>
    </div>

    <script>
        class MathEngine {
            constructor() {
                this.epsilon = 0.001;
            }
            
            parseFunction(functionString) {
                // Vereinfachter Parser f√ºr gebrochenrationale Funktionen
                const functions = {
                    1: { // Level 1: f(x) = 1/(x-2)
                        evaluate: (x) => 1 / (x - 2),
                        poles: [2],
                        asymptotes: { horizontal: 0, vertical: [2] },
                        discontinuities: []
                    },
                    2: { // Level 2: f(x) = 1/((x-1)(x+1))
                        evaluate: (x) => 1 / ((x - 1) * (x + 1)),
                        poles: [-1, 1],
                        asymptotes: { horizontal: 0, vertical: [-1, 1] },
                        discontinuities: []
                    },
                    3: { // Level 3: f(x) = (x-1)/((x-1)(x-2)) = 1/(x-2) mit L√ºcke bei x=1
                        evaluate: (x) => Math.abs(x - 1) < this.epsilon ? 1 : 1 / (x - 2),
                        poles: [2],
                        asymptotes: { horizontal: 0, vertical: [2] },
                        discontinuities: [1]
                    },
                    4: { // Level 4: f(x) = (x¬≤+1)/(x-1)
                        evaluate: (x) => (x * x + 1) / (x - 1),
                        poles: [1],
                        asymptotes: { horizontal: null, vertical: [1], oblique: { slope: 1, intercept: 1 } },
                        discontinuities: []
                    },
                    5: { // Level 5: f(x) = (x¬≤-4)/((x-1)(x+2)(x-3))
                        evaluate: (x) => (x * x - 4) / ((x - 1) * (x + 2) * (x - 3)),
                        poles: [-2, 1, 3],
                        asymptotes: { horizontal: 0, vertical: [-2, 1, 3] },
                        discontinuities: []
                    },
                    6: { // Level 6: f(x) = (x¬≥-2x)/(x¬≤-4) - Zeitverz√∂gerung
                        evaluate: (x) => (x * x * x - 2 * x) / (x * x - 4),
                        poles: [-2, 2],
                        asymptotes: { horizontal: null, vertical: [-2, 2], oblique: { slope: 1, intercept: 0 } },
                        discontinuities: [],
                        timeWarp: { zones: [-1, 1], factor: 0.3 } // Zeitlupe in diesen Zonen
                    },
                    7: { // Level 7: f(x) = 1/(x¬≤-1) - Gravitationswechsel
                        evaluate: (x) => 1 / (x * x - 1),
                        poles: [-1, 1],
                        asymptotes: { horizontal: 0, vertical: [-1, 1] },
                        discontinuities: [],
                        gravityZones: { 
                            left: { x: -3, strength: -0.8 }, // Schwerkraft nach oben
                            right: { x: 3, strength: 1.2 }   // Schwerkraft nach unten verst√§rkt
                        }
                    },
                    8: { // Level 8: f(x) = (x¬≤-1)/(x-1) - Multi-Path
                        evaluate: (x) => Math.abs(x - 1) < this.epsilon ? 2 : (x * x - 1) / (x - 1),
                        poles: [],
                        asymptotes: { horizontal: null, vertical: [], oblique: { slope: 1, intercept: 1 } },
                        discontinuities: [1],
                        multiPath: {
                            paths: [
                                { start: -2, end: 0.8, color: '#00ff00' },
                                { start: 1.2, end: 3, color: '#ff8800' }
                            ]
                        }
                    },
                    9: { // Level 9: f(x) = (x¬≥+1)/(x¬≤-1) - Inverser Boost
                        evaluate: (x) => (x * x * x + 1) / (x * x - 1),
                        poles: [-1, 1],
                        asymptotes: { horizontal: null, vertical: [-1, 1], oblique: { slope: 1, intercept: 0 } },
                        discontinuities: [],
                        inverseBoost: true // Asymptoten verlangsamen
                    },
                    10: { // Level 10: f(x) = (x‚Å¥-5x¬≤+4)/(x¬≥-2x¬≤-x+2) - Chaos-Modus
                        evaluate: (x) => (x * x * x * x - 5 * x * x + 4) / (x * x * x - 2 * x * x - x + 2),
                        poles: [-1, 1, 2],
                        asymptotes: { horizontal: null, vertical: [-1, 1, 2], oblique: { slope: 1, intercept: -1 } },
                        discontinuities: [],
                        chaosMode: true, // Zuf√§llige Effekte
                        chaosEffects: ['timeWarp', 'gravityShift', 'colorShift', 'sizeShift']
                    }
                };
                
                return functions[functionString] || functions[1];
            }
            
            isNearPole(x, poles) {
                return poles.some(pole => Math.abs(x - pole) < this.epsilon * 5);
            }
            
            isNearAsymptote(x, y, asymptotes) {
                // Pr√ºfe horizontale Asymptote
                if (asymptotes.horizontal !== null && Math.abs(y - asymptotes.horizontal) < 0.5) {
                    return true;
                }
                
                // Pr√ºfe schiefe Asymptote
                if (asymptotes.oblique) {
                    const asymptoteY = asymptotes.oblique.slope * x + asymptotes.oblique.intercept;
                    if (Math.abs(y - asymptoteY) < 0.5) {
                        return true;
                    }
                }
                
                return false;
            }
            
            safeEvaluate(func, x) {
                try {
                    const result = func.evaluate(x);
                    if (!isFinite(result)) return null;
                    return result;
                } catch (e) {
                    return null;
                }
            }
        }
        
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = 8;
                this.trail = [];
                this.maxTrailLength = 20;
                this.jumping = false;
                this.jumpTime = 0;
                this.jumpDuration = 50; // Arc-Jump Dauer in Frames
                this.gravity = -0.006; // derzeit ungenutzt im Arc-Jump, behalten f√ºr evtl. future
                this.boostTime = 0;
                // Arc-Jump Parameter
                this.jumpStartX = 0;
                this.jumpStartY = 0;
                this.jumpTargetX = 0;
                this.jumpTargetY = 0;
                this.ctrlX = 0;
                this.ctrlY = 0;
                
                // Neue Eigenschaften f√ºr erweiterte Level
                this.chaosColor = null;
                this.chaosSize = 1;
            }
            
            update(mathEngine, currentFunction) {
                // Bewegung nur am Boden (im Arc-Jump steuern wir x/y direkt)
                if (!this.jumping) {
                    this.x += this.vx;
                }
                
                // Sprung-Logik
                if (this.jumping) {
                    this.jumpTime++;
                    const t = Math.min(1, this.jumpTime / this.jumpDuration);
                    const omt = 1 - t;
                    // Quadratischer Bezier-Bogen
                    this.x = omt * omt * this.jumpStartX + 2 * omt * t * this.ctrlX + t * t * this.jumpTargetX;
                    this.y = omt * omt * this.jumpStartY + 2 * omt * t * this.ctrlY + t * t * this.jumpTargetY;
                    if (t >= 1) {
                        this.jumping = false;
                        this.jumpTime = 0;
                        // Snap auf Kurve zur Sicherheit
                        const newY = mathEngine.safeEvaluate(currentFunction, this.x);
                        if (newY !== null) this.y = newY;
                    }
                }
                
                // Y-Position aus Funktion berechnen (wenn nicht springend)
                if (!this.jumping) {
                    const newY = mathEngine.safeEvaluate(currentFunction, this.x);
                    if (newY !== null) {
                        this.y = newY;
                    }
                }
                
                // Trail aktualisieren
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }
                
                // Boost-Timer
                if (this.boostTime > 0) {
                    this.boostTime--;
                }
            }
            
            startArcJump(targetX, targetY) {
                if (this.jumping) return;
                this.jumping = true;
                this.jumpTime = 0;
                this.jumpStartX = this.x;
                this.jumpStartY = this.y;
                this.jumpTargetX = targetX;
                this.jumpTargetY = targetY;
                // Kontrollpunkt in der Mitte mit zus√§tzlicher H√∂he f√ºr sch√∂nen Bogen
                const midX = (this.jumpStartX + this.jumpTargetX) / 2;
                const baseMidY = (this.jumpStartY + this.jumpTargetY) / 2;
                const arcHeight = Math.max(0.6, Math.abs(this.jumpTargetY - this.jumpStartY) * 0.8) + 0.6;
                this.ctrlX = midX;
                this.ctrlY = baseMidY + arcHeight; // nach oben (Welt-y nimmt zu)
            }
            
            checkCollisions(mathEngine, currentFunction, game) {
                // Polstellen-Kollision
                if (!this.jumping && mathEngine.isNearPole(this.x, currentFunction.poles)) {
                    return 'pole';
                }
                
                // Asymptoten-Boost
                if (mathEngine.isNearAsymptote(this.x, this.y, currentFunction.asymptotes)) {
                    if (this.boostTime === 0) {
                        this.boostTime = 60;
                        return 'boost';
                    }
                }
                
                // Definitionsl√ºcken - mit Sprungpuffer ("Coyote Time")
                for (let disc of currentFunction.discontinuities) {
                    if (Math.abs(this.x - disc) < 0.35) {
                        if (this.jumping || (game && game.jumpBuffer > 0)) {
                            if (game) game.jumpBuffer = 0; // Buffer verbrauchen
                            return 'discontinuity_success'; // Erfolgreicher Sprung
                        } else {
                            // In Level 3 kein Tod an der L√ºcke ‚Äì Teleporter √ºbernimmt
                            if (game && game.currentLevel === 3) {
                                return null;
                            }
                            return 'discontinuity_fail'; // In anderen Levels: Bestrafung
                        }
                    }
                }
                
                return null;
            }
        }
        
        class Renderer {
            constructor(canvas, ctx) {
                this.canvas = canvas;
                this.ctx = ctx;
                this.scale = 50;
                this.offsetX = canvas.width / 2;
                this.offsetY = canvas.height / 2;
            }
            
            clear() {
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }
            
            worldToScreen(x, y) {
                return {
                    x: this.offsetX + x * this.scale,
                    y: this.offsetY - y * this.scale
                };
            }
            
            drawGrid() {
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)';
                this.ctx.lineWidth = 1;
                
                // Vertikale Linien
                for (let x = -10; x <= 10; x++) {
                    const screenX = this.offsetX + x * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenX, 0);
                    this.ctx.lineTo(screenX, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontale Linien
                for (let y = -6; y <= 6; y++) {
                    const screenY = this.offsetY - y * this.scale;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                }
                
                // Achsen
                this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                this.ctx.lineWidth = 2;
                
                // X-Achse
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.offsetY);
                this.ctx.lineTo(this.canvas.width, this.offsetY);
                this.ctx.stroke();
                
                // Y-Achse
                this.ctx.beginPath();
                this.ctx.moveTo(this.offsetX, 0);
                this.ctx.lineTo(this.offsetX, this.canvas.height);
                this.ctx.stroke();
            }
            
            drawFunction(mathEngine, func, playerX) {
                this.ctx.strokeStyle = '#00ffff';
                this.ctx.lineWidth = 3;
                this.ctx.shadowColor = '#00ffff';
                this.ctx.shadowBlur = 10;
                
                this.ctx.beginPath();
                let started = false;
                
                for (let screenX = 0; screenX < this.canvas.width; screenX += 2) {
                    const worldX = (screenX - this.offsetX) / this.scale;
                    const y = mathEngine.safeEvaluate(func, worldX);
                    
                    if (y !== null && Math.abs(y) < 10) {
                        const screenPos = this.worldToScreen(worldX, y);
                        
                        if (!started) {
                            this.ctx.moveTo(screenPos.x, screenPos.y);
                            started = true;
                        } else {
                            this.ctx.lineTo(screenPos.x, screenPos.y);
                        }
                    } else {
                        started = false;
                    }
                }
                
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }
            
            drawPoles(poles) {
                poles.forEach(pole => {
                    const screenPos = this.worldToScreen(pole, 0);
                    
                    // Energiewand-Effekt
                    this.ctx.strokeStyle = '#ff0000';
                    this.ctx.lineWidth = 4;
                    this.ctx.shadowColor = '#ff0000';
                    this.ctx.shadowBlur = 20;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(screenPos.x, 0);
                    this.ctx.lineTo(screenPos.x, this.canvas.height);
                    this.ctx.stroke();
                    
                    // Pulsierender Effekt
                    const pulse = Math.sin(Date.now() * 0.01) * 0.5 + 0.5;
                    this.ctx.shadowBlur = 10 + pulse * 20;
                    this.ctx.stroke();
                    
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawAsymptotes(asymptotes) {
                // Horizontale Asymptote
                if (asymptotes.horizontal !== null) {
                    const screenY = this.offsetY - asymptotes.horizontal * this.scale;
                    
                    this.ctx.strokeStyle = '#ff00ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = '#ff00ff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([10, 5]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, screenY);
                    this.ctx.lineTo(this.canvas.width, screenY);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                }
                
                // Schiefe Asymptote
                if (asymptotes.oblique) {
                    this.ctx.strokeStyle = '#ff00ff';
                    this.ctx.lineWidth = 2;
                    this.ctx.shadowColor = '#ff00ff';
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([10, 5]);
                    
                    this.ctx.beginPath();
                    for (let screenX = 0; screenX < this.canvas.width; screenX += 10) {
                        const worldX = (screenX - this.offsetX) / this.scale;
                        const y = asymptotes.oblique.slope * worldX + asymptotes.oblique.intercept;
                        const screenPos = this.worldToScreen(worldX, y);
                        
                        if (screenX === 0) {
                            this.ctx.moveTo(screenPos.x, screenPos.y);
                        } else {
                            this.ctx.lineTo(screenPos.x, screenPos.y);
                        }
                    }
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                }
            }
            
            drawDiscontinuities(discontinuities) {
                discontinuities.forEach(disc => {
                    const screenPos = this.worldToScreen(disc, 0);
                    
                    // Sprungmarkierung
                    this.ctx.fillStyle = '#ffff00';
                    this.ctx.shadowColor = '#ffff00';
                    this.ctx.shadowBlur = 10;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, this.offsetY, 15, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.fillStyle = '#000000';
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, this.offsetY, 8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.shadowBlur = 0;
                });
            }
            
            // Neue Visualisierungen f√ºr erweiterte Level
            drawTimeWarpZones(timeWarp) {
                if (!timeWarp) return;
                
                timeWarp.zones.forEach(zone => {
                    const screenPos = this.worldToScreen(zone, 0);
                    
                    // Zeitlupe-Zone als gr√ºne, pulsierende Kreise
                    this.ctx.strokeStyle = '#00ff00';
                    this.ctx.lineWidth = 3;
                    this.ctx.shadowColor = '#00ff00';
                    this.ctx.shadowBlur = 15;
                    
                    const pulse = Math.sin(Date.now() * 0.005) * 0.3 + 0.7;
                    this.ctx.globalAlpha = pulse;
                    
                    for (let i = 0; i < 3; i++) {
                        const radius = 20 + i * 15;
                        this.ctx.beginPath();
                        this.ctx.arc(screenPos.x, this.offsetY, radius, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                    
                    this.ctx.globalAlpha = 1;
                    this.ctx.shadowBlur = 0;
                });
            }
            
            drawGravityZones(gravityZones) {
                if (!gravityZones) return;
                
                // Linke Gravitationszone
                if (gravityZones.left) {
                    const screenPos = this.worldToScreen(gravityZones.left.x, 0);
                    this.drawGravityZone(screenPos, gravityZones.left.strength, '#ff0080');
                }
                
                // Rechte Gravitationszone
                if (gravityZones.right) {
                    const screenPos = this.worldToScreen(gravityZones.right.x, 0);
                    this.drawGravityZone(screenPos, gravityZones.right.strength, '#8000ff');
                }
            }
            
            drawGravityZone(screenPos, strength, color) {
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 4;
                this.ctx.shadowColor = color;
                this.ctx.shadowBlur = 20;
                
                // Gravitationslinien
                const lineCount = Math.abs(Math.floor(strength * 5));
                const lineLength = 30;
                
                for (let i = 0; i < lineCount; i++) {
                    const x = screenPos.x + (i - lineCount/2) * 8;
                    const y = this.offsetY;
                    
                    this.ctx.beginPath();
                    if (strength > 0) {
                        // Schwerkraft nach unten
                        this.ctx.moveTo(x, y - lineLength);
                        this.ctx.lineTo(x, y + lineLength);
                    } else {
                        // Schwerkraft nach oben
                        this.ctx.moveTo(x, y + lineLength);
                        this.ctx.lineTo(x, y - lineLength);
                    }
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
            }
            
            drawMultiPath(multiPath) {
                if (!multiPath) return;
                
                multiPath.paths.forEach((path, index) => {
                    const startPos = this.worldToScreen(path.start, 0);
                    const endPos = this.worldToScreen(path.end, 0);
                    
                    // Pfad-Markierung
                    this.ctx.strokeStyle = path.color;
                    this.ctx.lineWidth = 6;
                    this.ctx.shadowColor = path.color;
                    this.ctx.shadowBlur = 15;
                    this.ctx.setLineDash([15, 10]);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(startPos.x, this.offsetY);
                    this.ctx.lineTo(endPos.x, this.offsetY);
                    this.ctx.stroke();
                    
                    this.ctx.setLineDash([]);
                    this.ctx.shadowBlur = 0;
                    
                    // Pfad-Nummer
                    this.ctx.fillStyle = path.color;
                    this.ctx.font = 'bold 16px Orbitron';
                    this.ctx.textAlign = 'center';
                    const midX = (startPos.x + endPos.x) / 2;
                    this.ctx.fillText(`Pfad ${index + 1}`, midX, this.offsetY - 25);
                });
            }

            // Zus√§tzliche Teleporter-Markierungen f√ºr Level 3
            drawTeleporterMarkers(discontinuities) {
                discontinuities.forEach(disc => {
                    const center = this.worldToScreen(disc, 0);
                    const ctx = this.ctx;
                    const rings = [22, 28, 34];
                    rings.forEach((r, i) => {
                        ctx.strokeStyle = i % 2 === 0 ? '#ff00ff' : '#ffff00';
                        ctx.lineWidth = 2;
                        ctx.shadowColor = ctx.strokeStyle;
                        ctx.shadowBlur = 12;
                        ctx.beginPath();
                        ctx.arc(center.x, this.offsetY, r, 0, Math.PI * 2);
                        ctx.stroke();
                    });
                    ctx.shadowBlur = 0;
                });
            }
            
            drawPlayer(player) {
                const screenPos = this.worldToScreen(player.x, player.y);
                
                // Trail zeichnen
                if (player.trail.length > 1) {
                    this.ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    
                    for (let i = 0; i < player.trail.length; i++) {
                        const trailPos = this.worldToScreen(player.trail[i].x, player.trail[i].y);
                        if (i === 0) {
                            this.ctx.moveTo(trailPos.x, trailPos.y);
                        } else {
                            this.ctx.lineTo(trailPos.x, trailPos.y);
                        }
                    }
                    this.ctx.stroke();
                }
                
                // Spieler zeichnen
                let playerColor = player.boostTime > 0 ? '#ffff00' : '#00ffff';
                let playerShadow = player.boostTime > 0 ? '#ffff00' : '#00ffff';
                
                // Chaos-Modus: Zuf√§llige Farbe
                if (player.chaosColor) {
                    playerColor = player.chaosColor;
                    playerShadow = player.chaosColor;
                }
                
                this.ctx.fillStyle = playerColor;
                this.ctx.shadowColor = playerShadow;
                this.ctx.shadowBlur = player.boostTime > 0 ? 25 : 15;
                
                // Chaos-Modus: Gr√∂√üen√§nderung
                const radius = player.radius * (player.chaosSize || 1);
                
                this.ctx.beginPath();
                this.ctx.arc(screenPos.x, screenPos.y, radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Sprung-Indikator
                if (player.jumping) {
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, screenPos.y, player.radius + 5, 0, Math.PI * 2);
                    this.ctx.stroke();
                }
                
                this.ctx.shadowBlur = 0;
            }
            
            drawParticles(particles) {
                particles.forEach(particle => {
                    const screenPos = this.worldToScreen(particle.x, particle.y);
                    
                    this.ctx.fillStyle = `rgba(${particle.color.r}, ${particle.color.g}, ${particle.color.b}, ${particle.alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(screenPos.x, screenPos.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
        }
        
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.mathEngine = new MathEngine();
                this.renderer = new Renderer(this.canvas, this.ctx);
                
                this.player = new Player(-5, 0);
                this.currentLevel = 1;
                this.score = 0;
                this.lives = 3;
                this.gameRunning = true;
                this.particles = [];
                this.jumpBuffer = 0; // kurzzeitiger Sprungpuffer f√ºr forgiving timing
                this.levelStartCooldown = 0; // Frames bis Levelabschluss erlaubt ist
                this.teleportCooldown = 0; // Cooldown f√ºr Teleporter (Frames)
                // Jump-Forward-Dash Parameter
                this.jumpDashFrames = 24; // wie lange zus√§tzlicher Vorschub wirkt
                this.jumpDashMultiplier = 3.0; // wie stark der Vorschub ist
                
                // Neue Level-Mechaniken
                this.timeWarpActive = false;
                this.timeWarpFactor = 1;
                this.gravityShift = 0;
                this.chaosMode = false;
                this.chaosTimer = 0;
                this.currentPath = 0; // F√ºr Multi-Path Level
                
                this.keys = {};
                this.currentFunction = null;
                
                this.loadLevel(this.currentLevel);
                this.setupEventListeners();
                this.gameLoop();
            }
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.startJump();
                        this.jumpBuffer = 12; // wenige Frames Puffer aktivieren
                    }
                    
                    if (e.code === 'KeyR') {
                        this.restart();
                    }
                    
                    // Multi-Path Level 8: Pfad-Wechsel
                    if (e.code === 'Digit1' || e.code === 'Digit2') {
                        if (this.currentLevel === 8 && this.currentFunction.multiPath) {
                            const pathIndex = parseInt(e.code.replace('Digit', '')) - 1;
                            if (pathIndex < this.currentFunction.multiPath.paths.length) {
                                this.currentPath = pathIndex;
                                this.switchToPath(pathIndex);
                            }
                        }
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
            }
            
            // Teleportiere den Spieler in Level 3 an der L√ºcke auf die rechte Seite
            tryTeleportAtDiscontinuity(prevX) {
                if (this.currentLevel !== 3) return;
                if (this.teleportCooldown > 0) return;
                if (this.player.jumping) return;
                const discs = this.currentFunction.discontinuities || [];
                for (let disc of discs) {
                    const nearNow = Math.abs(this.player.x - disc) < 0.35; // wie Kollision
                    const crossed = (Math.min(prevX, this.player.x) - 0.02) <= disc && (Math.max(prevX, this.player.x) + 0.02) >= disc;
                    if (nearNow || crossed) {
                        let newX = disc + 0.7;
                        let newY = this.mathEngine.safeEvaluate(this.currentFunction, newX);
                        if (newY === null) {
                            const step = 0.1;
                            for (let i = 1; i <= 10 && newY === null; i++) {
                                newX = disc + 0.6 + i * step;
                                newY = this.mathEngine.safeEvaluate(this.currentFunction, newX);
                            }
                        }
                        this.player.x = newX;
                        if (newY !== null) this.player.y = newY;
                        this.teleportCooldown = 18; // ~0.3s
                        // kleines Feedback
                        this.addScore(100);
                        if (this.createJumpParticles) this.createJumpParticles();
                        break;
                    }
                }
            }
            
            // Berechne ein sinnvolles Landeziel rechts von der aktuellen Position
            computeJumpTargetX() {
                const x0 = this.player.x;
                const maxReach = 2.2; // maximale horizontale Reichweite eines Sprungs
                let target = x0 + 1.2; // Default-Landeplatz
                // Suche n√§chstgelegenes Hindernis rechts (Pol oder L√ºcke)
                const candidates = [
                    ...(this.currentFunction.poles || []),
                    ...(this.currentFunction.discontinuities || [])
                ].filter(x => x > x0 && x - x0 < maxReach).sort((a,b)=>a-b);
                if (candidates.length > 0) {
                    const obst = candidates[0];
                    target = obst + 0.6; // etwas hinter dem Hindernis landen
                }
                return target;
            }

            // Starte einen deterministischen Bogen-Sprung zur anderen Kurve
            startJump() {
                if (this.player.jumping) return;
                let targetX = this.computeJumpTargetX();
                let targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX);
                // Falls direkt auf Pol/L√ºcke, etwas weiter springen
                if (targetY === null) {
                    const delta = 0.2;
                    for (let i = 1; i <= 5 && targetY === null; i++) {
                        targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX + i * delta);
                        if (targetY !== null) { targetX += i * delta; break; }
                    }
                }
                if (targetY === null) {
                    // Fallback: kleine Verschiebung oberhalb der aktuellen y
                    targetY = (this.player.y + 0.5);
                }
                this.player.startArcJump(targetX, targetY);
            }
            
            loadLevel(level) {
                this.currentFunction = this.mathEngine.parseFunction(level);
                // Basisgeschwindigkeit pro Level (Level 1 langsam, pro Level schneller)
                this.baseSpeed = 0.003 + (level - 1) * 0.006;
                if (level === 3) {
                    // Level 3 etwas langsamer, um Teleporter/Sprung zu √ºben
                    this.baseSpeed *= 0.8;
                }
                
                // Spezielle Level-Mechaniken
                if (level === 6) {
                    // Level 6: Zeitlupe in bestimmten Zonen
                    this.timeWarpActive = true;
                } else {
                    this.timeWarpActive = false;
                }
                
                if (level === 7) {
                    // Level 7: Gravitationswechsel
                    this.gravityShift = 0;
                } else {
                    this.gravityShift = 0;
                }
                
                if (level === 8) {
                    // Level 8: Multi-Path
                    this.currentPath = 0;
                }
                
                if (level === 9) {
                    // Level 9: Inverser Boost
                    // Wird in der Kollisionserkennung behandelt
                }
                
                if (level === 10) {
                    // Level 10: Chaos-Modus
                    this.chaosMode = true;
                    this.chaosTimer = 0;
                } else {
                    this.chaosMode = false;
                }
                // Spawn-Position je nach Level-Schwierigkeit
                this.player.x = this.getSpawnPosition(level);
                this.player.y = this.mathEngine.safeEvaluate(this.currentFunction, this.player.x) || 0;
                // Spielerzustand vollst√§ndig zur√ºcksetzen
                this.player.trail = [];
                this.player.jumping = false;
                this.player.jumpTime = 0;
                this.player.boostTime = 0;
                // Arc-Parameter zur√ºcksetzen
                this.player.jumpStartX = this.player.x;
                this.player.jumpStartY = this.player.y;
                this.player.jumpTargetX = this.player.x;
                this.player.jumpTargetY = this.player.y;
                // Eingaben und Buffer/Cooldown zur√ºcksetzen
                this.keys = {};
                this.jumpBuffer = 0;
                this.levelStartCooldown = 30; // ~0.5s bei 60fps
                this.teleportCooldown = 0;
                
                // UI aktualisieren
                document.getElementById('level').textContent = `Level: ${level}`;
                
                const functionTexts = {
                    1: 'f(x) = 1/(x-2)',
                    2: 'f(x) = 1/((x-1)(x+1))',
                    3: 'f(x) = (x-1)/((x-1)(x-2)) ‚Äî Teleporter an der gelben L√ºcke! Springe f√ºr Bonus.',
                    4: 'f(x) = (x¬≤+1)/(x-1)',
                    5: 'f(x) = (x¬≤-4)/((x-1)(x+2)(x-3))',
                    6: 'f(x) = (x¬≥-2x)/(x¬≤-4) ‚Äî Zeitlupe in gr√ºnen Zonen!',
                    7: 'f(x) = 1/(x¬≤-1) ‚Äî Gravitationswechsel! Schwerkraft √§ndert sich!',
                    8: 'f(x) = (x¬≤-1)/(x-1) ‚Äî Multi-Path! W√§hle deinen Weg!',
                    9: 'f(x) = (x¬≥+1)/(x¬≤-1) ‚Äî Inverser Boost! Asymptoten verlangsamen!',
                    10: 'f(x) = (x‚Å¥-5x¬≤+4)/(x¬≥-2x¬≤-x+2) ‚Äî Chaos-Modus! Alles ist m√∂glich!'
                };
                
                document.getElementById('function').textContent = functionTexts[level] || functionTexts[1];
            }
            
            update() {
                if (!this.gameRunning) return;
                const prevX = this.player.x;
                
                // Automatisches Fahren nach rechts (geschwindigkeitsabh√§ngig pro Level)
                this.player.vx = this.baseSpeed; // Grundgeschwindigkeit pro Level
                
                // Manuelle Geschwindigkeitskontrolle (optional)
                if (this.keys['ArrowLeft'] || this.keys['KeyA']) {
                    this.player.vx *= 0.5; // Verlangsamen
                }
                if (this.keys['ArrowRight'] || this.keys['KeyD']) {
                    this.player.vx *= 1.5; // Beschleunigen
                }
                
                // Boost-Geschwindigkeit
                if (this.player.boostTime > 0) {
                    if (this.currentLevel === 9 && this.currentFunction.inverseBoost) {
                        // Level 9: Inverser Boost - verlangsamt
                        this.player.vx *= 0.3;
                    } else {
                        // Normaler Boost
                        this.player.vx *= 2;
                    }
                }
                
                // Level 6: Zeitlupe in bestimmten Zonen
                if (this.timeWarpActive && this.currentFunction.timeWarp) {
                    const inTimeWarpZone = this.currentFunction.timeWarp.zones.some(zone => 
                        Math.abs(this.player.x - zone) < 1
                    );
                    if (inTimeWarpZone) {
                        this.timeWarpFactor = this.currentFunction.timeWarp.factor;
                        this.player.vx *= this.timeWarpFactor;
                    } else {
                        this.timeWarpFactor = 1;
                    }
                }
                
                // Level 7: Gravitationswechsel
                if (this.currentLevel === 7 && this.currentFunction.gravityZones) {
                    if (this.player.x < this.currentFunction.gravityZones.left.x) {
                        this.gravityShift = this.currentFunction.gravityZones.left.strength;
                    } else if (this.player.x > this.currentFunction.gravityZones.right.x) {
                        this.gravityShift = this.currentFunction.gravityZones.right.strength;
                    } else {
                        this.gravityShift = 0;
                    }
                }
                
                // Level 10: Chaos-Modus
                if (this.chaosMode) {
                    this.chaosTimer++;
                    if (this.chaosTimer % 120 === 0) { // Alle 2 Sekunden
                        this.triggerRandomChaosEffect();
                    }
                }
                
                // W√§hrend des Arc-Sprungs steuert der Bogen x/y direkt ‚Äì kein Air-Assist n√∂tig
                
                this.player.update(this.mathEngine, this.currentFunction);

                // Sprungpuffer herunterz√§hlen
                if (this.jumpBuffer > 0) this.jumpBuffer--;
                if (this.levelStartCooldown > 0) this.levelStartCooldown--;
                if (this.teleportCooldown > 0) this.teleportCooldown--;

                // Level 3: Teleporter an Definitionsl√ºcke
                this.tryTeleportAtDiscontinuity(prevX);

                // Kollisionserkennung
                const collision = this.player.checkCollisions(this.mathEngine, this.currentFunction, this);
                
                if (collision === 'pole') {
                    this.loseLife();
                } else if (collision === 'boost') {
                    this.addScore(100); // Score nur durch Boost
                    this.createBoostParticles();
                } else if (collision === 'discontinuity_success') {
                    this.addScore(200); // Score nur durch erfolgreichen Sprung
                    this.createJumpParticles();
                } else if (collision === 'discontinuity_fail') {
                    this.loseLife(); // Bestrafung f√ºr vergessenen Sprung
                }
                
                // Kein automatischer Score mehr!
                
                // Level-Completion (Spieler erreicht x = 5) ‚Äì erst nach Cooldown
                if (this.levelStartCooldown === 0 && this.player.x > 5) {
                    this.completeLevel();
                }
                
                // Partikel aktualisieren
                this.updateParticles();
                
                // Kamera folgt Spieler
                this.renderer.offsetX = this.canvas.width / 2 - this.player.x * this.renderer.scale;
            }
            
            render() {
                this.renderer.clear();
                this.renderer.drawGrid();
                this.renderer.drawAsymptotes(this.currentFunction.asymptotes);
                this.renderer.drawFunction(this.mathEngine, this.currentFunction, this.player.x);
                this.renderer.drawPoles(this.currentFunction.poles);
                this.renderer.drawDiscontinuities(this.currentFunction.discontinuities);
                
                // Level-spezifische Visualisierungen
                if (this.currentLevel === 3) {
                    this.renderer.drawTeleporterMarkers(this.currentFunction.discontinuities);
                }
                if (this.currentLevel === 6 && this.currentFunction.timeWarp) {
                    this.renderer.drawTimeWarpZones(this.currentFunction.timeWarp);
                }
                if (this.currentLevel === 7 && this.currentFunction.gravityZones) {
                    this.renderer.drawGravityZones(this.currentFunction.gravityZones);
                }
                if (this.currentLevel === 8 && this.currentFunction.multiPath) {
                    this.renderer.drawMultiPath(this.currentFunction.multiPath);
                }
                
                this.renderer.drawParticles(this.particles);
                this.renderer.drawPlayer(this.player);
            }
            
            gameLoop() {
                this.update();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            addScore(points) {
                this.score += points;
                document.getElementById('score').textContent = `Score: ${this.score}`;
            }
            
            loseLife() {
                this.lives--;
                document.getElementById('lives').textContent = `Lives: ${this.lives}`;
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Respawn an der levelabh√§ngigen Position
                    this.player.x = this.getSpawnPosition(this.currentLevel);
                    this.player.y = this.mathEngine.safeEvaluate(this.currentFunction, this.player.x) || 0;
                    this.player.trail = [];
                    this.player.jumping = false;
                    this.player.jumpTime = 0;
                    this.player.boostTime = 0;
                    // Arc-Parameter zur√ºcksetzen
                    this.player.jumpStartX = this.player.x;
                    this.player.jumpStartY = this.player.y;
                    this.player.jumpTargetX = this.player.x;
                    this.player.jumpTargetY = this.player.y;
                }
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            completeLevel() {
                const bonus = this.lives * 500;
                this.addScore(bonus);
                
                document.getElementById('levelBonus').textContent = bonus;
                document.getElementById('levelComplete').style.display = 'block';
                this.gameRunning = false;
            }
            
            nextLevel() {
                this.currentLevel++;
                if (this.currentLevel > 10) {
                    alert('Herzlichen Gl√ºckwunsch! Du hast alle 10 Level geschafft! Du bist ein Asymptoten-Meister! üéâ');
                    this.restart();
                    return;
                }
                
                this.loadLevel(this.currentLevel);
                document.getElementById('levelComplete').style.display = 'none';
                this.gameRunning = true;
            }
            
            restart() {
                this.currentLevel = 1;
                this.score = 0;
                this.lives = 3;
                this.gameRunning = true;
                this.particles = [];
                
                // Alle Level-Mechaniken zur√ºcksetzen
                this.timeWarpActive = false;
                this.timeWarpFactor = 1;
                this.gravityShift = 0;
                this.chaosMode = false;
                this.chaosTimer = 0;
                this.currentPath = 0;
                
                this.loadLevel(this.currentLevel);
                
                document.getElementById('score').textContent = `Score: ${this.score}`;
                document.getElementById('lives').textContent = `Lives: ${this.lives}`;
                document.getElementById('gameOver').style.display = 'none';
                document.getElementById('levelComplete').style.display = 'none';
            }
            
            createBoostParticles() {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.5,
                        y: this.player.y + (Math.random() - 0.5) * 0.5,
                        vx: (Math.random() - 0.5) * 0.1,
                        vy: (Math.random() - 0.5) * 0.1,
                        size: Math.random() * 3 + 1,
                        alpha: 1,
                        color: { r: 255, g: 255, b: 0 },
                        life: 60
                    });
                }
            }
            
            createJumpParticles() {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.3,
                        y: this.player.y + (Math.random() - 0.5) * 0.3,
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: (Math.random() - 0.5) * 0.15,
                        size: Math.random() * 4 + 2,
                        alpha: 1,
                        color: { r: 0, g: 255, b: 255 },
                        life: 45
                    });
                }
            }
            
            updateParticles() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.life--;
                    particle.alpha = particle.life / 60;
                    
                    return particle.life > 0;
                });
            }
            
            triggerRandomChaosEffect() {
                if (!this.chaosMode) return;
                
                const effects = this.currentFunction.chaosEffects || [];
                if (effects.length === 0) return;
                
                const randomEffect = effects[Math.floor(Math.random() * effects.length)];
                
                switch (randomEffect) {
                    case 'timeWarp':
                        this.timeWarpFactor = Math.random() * 0.5 + 0.3; // 0.3 bis 0.8
                        this.player.vx *= this.timeWarpFactor;
                        this.createTimeWarpParticles();
                        break;
                    case 'gravityShift':
                        this.gravityShift = (Math.random() - 0.5) * 2; // -1 bis 1
                        this.createGravityParticles();
                        break;
                    case 'colorShift':
                        // Spielerfarbe √§ndern
                        this.player.chaosColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        setTimeout(() => { this.player.chaosColor = null; }, 3000);
                        break;
                    case 'sizeShift':
                        // Spielergr√∂√üe √§ndern
                        this.player.chaosSize = Math.random() * 1.5 + 0.5; // 0.5 bis 2.0
                        setTimeout(() => { this.player.chaosSize = 1; }, 3000);
                        break;
                }
            }
            
            createTimeWarpParticles() {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.8,
                        y: this.player.y + (Math.random() - 0.5) * 0.8,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        size: Math.random() * 4 + 2,
                        alpha: 1,
                        color: { r: 0, g: 255, b: 0 },
                        life: 90
                    });
                }
            }
            
            createGravityParticles() {
                for (let i = 0; i < 6; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.6,
                        y: this.player.y + (Math.random() - 0.5) * 0.6,
                        vx: (Math.random() - 0.5) * 0.15,
                        vy: this.gravityShift * 0.1,
                        size: Math.random() * 3 + 1,
                        alpha: 1,
                        color: { r: 255, g: 0, b: 255 },
                        life: 75
                    });
                }
            }
            
            switchToPath(pathIndex) {
                if (this.currentLevel !== 8 || !this.currentFunction.multiPath) return;
                
                const path = this.currentFunction.multiPath.paths[pathIndex];
                if (!path) return;
                
                // Spieler auf den gew√§hlten Pfad teleportieren
                const targetX = (path.start + path.end) / 2;
                const targetY = this.mathEngine.safeEvaluate(this.currentFunction, targetX);
                
                if (targetY !== null) {
                    this.player.x = targetX;
                    this.player.y = targetY;
                    
                    // Partikel-Effekt f√ºr Pfad-Wechsel
                    this.createPathSwitchParticles();
                    
                    // Score-Bonus f√ºr Pfad-Wechsel
                    this.addScore(150);
                }
            }
            
            createPathSwitchParticles() {
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: this.player.x + (Math.random() - 0.5) * 0.8,
                        y: this.player.y + (Math.random() - 0.5) * 0.8,
                        vx: (Math.random() - 0.5) * 0.2,
                        vy: (Math.random() - 0.5) * 0.2,
                        size: Math.random() * 5 + 3,
                        alpha: 1,
                        color: { r: 255, g: 255, b: 0 },
                        life: 60
                    });
                }
            }
            
            // Hilfsfunktion f√ºr Spawn-Position
            getSpawnPosition(level) {
                if (level >= 1 && level <= 3) return -5;      // Einfache Level
                if (level >= 4 && level <= 6) return -12;     // Mittlere Schwierigkeit - viel weiter links
                if (level >= 7 && level <= 9) return -18;     // Hohe Schwierigkeit - noch weiter links
                if (level === 10) return -25;                 // Chaos-Modus - am weitesten links
                return -5; // Fallback
            }
        }
        
        // Spiel starten
        let game;
        window.addEventListener('load', () => {
            game = new Game();
        });
    </script>
</body>
</html>
