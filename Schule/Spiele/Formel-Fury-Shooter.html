<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formel-Fury-Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            display: block;
            background-color: #111;
            cursor: crosshair;
        }

        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        #gameInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 14px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        /* Game UI System */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
        }

        #formulaHUD {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #001a00, #003300);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 20px #00ff0080,
                inset 0 0 20px #00ff0020;
            pointer-events: auto;
            display: none;
            min-width: 400px;
            text-align: center;
        }

        #formulaDisplay {
            background: #000;
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff0080;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #formulaInput {
            width: 100%;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff0080;
            outline: none;
            margin-bottom: 15px;
        }

        #formulaInput:focus {
            box-shadow: 0 0 15px #00ff00;
            border-color: #00ff88;
        }

        #formulaInput::placeholder {
            color: #00ff0060;
        }

        #formulaButtons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .formula-btn {
            background: linear-gradient(145deg, #003300, #006600);
            border: 1px solid #00ff00;
            border-radius: 6px;
            padding: 8px 16px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 5px #00ff0080;
        }

        .formula-btn:hover {
            background: linear-gradient(145deg, #006600, #009900);
            box-shadow: 0 0 10px #00ff0060;
        }

        .formula-btn:active {
            transform: scale(0.95);
        }

        #feedbackDisplay {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 300;
            animation: feedbackPulse 0.5s ease-out;
        }

        .feedback-correct {
            background: linear-gradient(145deg, #003300, #006600);
            color: #00ff00;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px #00ff0080;
        }

        .feedback-incorrect {
            background: linear-gradient(145deg, #330000, #660000);
            color: #ff0000;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px #ff000080;
        }

        @keyframes feedbackPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        #scoreDisplay {
            position: absolute;
            top: 80px;
            left: 10px;
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Game UI Overlay -->
    <div id="gameUI">
        <!-- Formula Challenge HUD -->
        <div id="formulaHUD">
            <div id="formulaDisplay">Drücke SPACE für eine neue Formel...</div>
            <input type="text" id="formulaInput" placeholder="Gib die Lösung ein... (z.B. x² + 4x + 4)" />
            <div id="formulaButtons">
                <button class="formula-btn" onclick="game.formulaSystem.submitAnswer()">Antworten</button>
                <button class="formula-btn" onclick="game.formulaSystem.skipFormula()">Überspringen</button>
                <button class="formula-btn" onclick="game.formulaSystem.hideFormulaHUD()">Schließen</button>
            </div>
        </div>
        
        <!-- Feedback Display -->
        <div id="feedbackDisplay"></div>
    </div>
    
    <!-- HUD Elements -->
    <div id="fpsCounter">FPS: 0</div>
    <div id="scoreDisplay">
        <div>Score: <span id="scoreValue">0</span></div>
        <div>Richtig: <span id="correctCount">0</span></div>
        <div>Falsch: <span id="incorrectCount">0</span></div>
    </div>
    <div id="gameInfo">
        <div>Formel-Fury-Shooter v0.4</div>
        <div>Phase 2.1: Enemy System</div>
        <div>Controls: WASD + SPACE, nähere dich Gegnern!</div>
    </div>

    <script>
        class FormulaSystem {
            constructor() {
                this.currentFormula = null;
                this.currentSolution = null;
                this.score = 0;
                this.correctAnswers = 0;
                this.incorrectAnswers = 0;
                
                // UI Elements
                this.formulaHUD = document.getElementById('formulaHUD');
                this.formulaDisplay = document.getElementById('formulaDisplay');
                this.formulaInput = document.getElementById('formulaInput');
                this.feedbackDisplay = document.getElementById('feedbackDisplay');
                this.scoreValue = document.getElementById('scoreValue');
                this.correctCount = document.getElementById('correctCount');
                this.incorrectCount = document.getElementById('incorrectCount');
                
                this.setupEventListeners();
                this.generateFormula();
            }

            setupEventListeners() {
                // Enter key to submit answer
                this.formulaInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.submitAnswer();
                    }
                });
            }

            generateFormula() {
                // Generate simple binomial formulas of type (a + b)²
                const a = Math.floor(Math.random() * 5) + 1; // 1-5
                const b = Math.floor(Math.random() * 5) + 1; // 1-5
                const variable = ['x', 'y', 'z'][Math.floor(Math.random() * 3)];
                
                // Create formula like (2x + 3)²
                const formulaText = `(${a}${variable} + ${b})²`;
                
                // Calculate solution: (ax + b)² = a²x² + 2abx + b²
                const coefficient_x2 = a * a;
                const coefficient_x = 2 * a * b;
                const constant = b * b;
                
                const formula = {
                    text: formulaText,
                    a: a,
                    b: b,
                    variable: variable,
                    coefficients: {
                        x2: coefficient_x2,
                        x: coefficient_x,
                        constant: constant
                    }
                };
                
                // Create multiple valid solution formats
                const solutions = this.generateSolutionVariants(coefficient_x2, coefficient_x, constant, variable);
                formula.solutions = solutions;
                
                // Update current formula for UI
                this.currentFormula = formula;
                this.currentSolution = solutions;
                
                console.log('Generated formula:', formulaText);
                console.log('Expected solutions:', solutions);
                
                return formula; // Return formula object for enemies
            }

            generateSolutionVariants(a2, a1, a0, variable) {
                const solutions = [];
                
                // Standard form: ax² + bx + c
                if (a1 > 0) {
                    solutions.push(`${a2}${variable}² + ${a1}${variable} + ${a0}`);
                    solutions.push(`${a2}${variable}^2 + ${a1}${variable} + ${a0}`);
                } else {
                    solutions.push(`${a2}${variable}² - ${Math.abs(a1)}${variable} + ${a0}`);
                    solutions.push(`${a2}${variable}^2 - ${Math.abs(a1)}${variable} + ${a0}`);
                }
                
                // With spaces
                if (a1 > 0) {
                    solutions.push(`${a2} ${variable}² + ${a1} ${variable} + ${a0}`);
                    solutions.push(`${a2} ${variable}^2 + ${a1} ${variable} + ${a0}`);
                } else {
                    solutions.push(`${a2} ${variable}² - ${Math.abs(a1)} ${variable} + ${a0}`);
                    solutions.push(`${a2} ${variable}^2 - ${Math.abs(a1)} ${variable} + ${a0}`);
                }
                
                // Handle coefficient 1
                const x2_term = a2 === 1 ? `${variable}²` : `${a2}${variable}²`;
                const x2_term_alt = a2 === 1 ? `${variable}^2` : `${a2}${variable}^2`;
                const x_term = a1 === 1 ? variable : `${a1}${variable}`;
                
                if (a1 > 0) {
                    solutions.push(`${x2_term} + ${x_term} + ${a0}`);
                    solutions.push(`${x2_term_alt} + ${x_term} + ${a0}`);
                } else {
                    solutions.push(`${x2_term} - ${Math.abs(a1) === 1 ? variable : Math.abs(a1) + variable} + ${a0}`);
                    solutions.push(`${x2_term_alt} - ${Math.abs(a1) === 1 ? variable : Math.abs(a1) + variable} + ${a0}`);
                }
                
                return solutions;
            }

            normalizeExpression(expr) {
                return expr
                    .toLowerCase()
                    .replace(/\s+/g, '') // Remove all spaces
                    .replace(/\^2/g, '²') // Convert ^2 to ²
                    .replace(/\*([xyz])/g, '$1') // Remove * before variables
                    .replace(/([xyz])\*/g, '$1') // Remove * after variables
                    .replace(/\+\+/g, '+') // Fix double plus
                    .replace(/--/g, '+') // Convert -- to +
                    .replace(/\+-/g, '-') // Convert +- to -
                    .replace(/-\+/g, '-'); // Convert -+ to -
            }

            validateAnswer(userInput) {
                const normalizedInput = this.normalizeExpression(userInput);
                
                for (let solution of this.currentSolution) {
                    const normalizedSolution = this.normalizeExpression(solution);
                    if (normalizedInput === normalizedSolution) {
                        return true;
                    }
                }
                
                // Additional check for different order (ax² + c + bx)
                const { x2, x, constant } = this.currentFormula.coefficients;
                const variable = this.currentFormula.variable;
                
                // Check if user wrote terms in different order
                const userHasX2 = normalizedInput.includes(`${x2 === 1 ? '' : x2}${variable}²`) || 
                                 normalizedInput.includes(`${x2 === 1 ? '' : x2}${variable}^2`);
                const userHasX = normalizedInput.includes(`${Math.abs(x) === 1 ? (x > 0 ? '' : '-') : x}${variable}`);
                const userHasConstant = normalizedInput.includes(constant.toString());
                
                return userHasX2 && userHasX && userHasConstant;
            }

            submitAnswer() {
                const userAnswer = this.formulaInput.value.trim();
                
                if (!userAnswer) {
                    this.showFeedback('Bitte gib eine Antwort ein!', false);
                    return;
                }
                
                const isCorrect = this.validateAnswer(userAnswer);
                
                if (isCorrect) {
                    this.correctAnswers++;
                    this.score += 100;
                    this.showFeedback('Richtig! +100 Punkte', true);
                } else {
                    this.incorrectAnswers++;
                    this.score = Math.max(0, this.score - 25);
                    this.showFeedback(`Falsch! Richtig wäre: ${this.currentSolution[0]}`, false);
                }
                
                this.updateScoreDisplay();
                this.formulaInput.value = '';
                
                // Generate new formula after a delay
                setTimeout(() => {
                    this.generateFormula();
                    this.showFormulaHUD();
                }, 2000);
            }

            skipFormula() {
                this.showFeedback(`Übersprungen! Lösung war: ${this.currentSolution[0]}`, false);
                this.formulaInput.value = '';
                
                setTimeout(() => {
                    this.generateFormula();
                    this.showFormulaHUD();
                }, 1500);
            }

            showFeedback(message, isCorrect) {
                this.feedbackDisplay.textContent = message;
                this.feedbackDisplay.className = isCorrect ? 'feedback-correct' : 'feedback-incorrect';
                this.feedbackDisplay.style.display = 'block';
                
                setTimeout(() => {
                    this.feedbackDisplay.style.display = 'none';
                }, 2000);
            }

            updateScoreDisplay() {
                this.scoreValue.textContent = this.score;
                this.correctCount.textContent = this.correctAnswers;
                this.incorrectCount.textContent = this.incorrectAnswers;
            }

            showFormulaHUD() {
                this.formulaDisplay.textContent = this.currentFormula.text;
                this.formulaHUD.style.display = 'block';
                this.formulaInput.focus();
            }

            hideFormulaHUD() {
                this.formulaHUD.style.display = 'none';
            }

            toggleFormulaHUD() {
                if (this.formulaHUD.style.display === 'none' || !this.formulaHUD.style.display) {
                    this.showFormulaHUD();
                } else {
                    this.hideFormulaHUD();
                }
            }

            getDebugInfo() {
                return {
                    currentFormula: this.currentFormula ? this.currentFormula.text : 'None',
                    score: this.score,
                    correct: this.correctAnswers,
                    incorrect: this.incorrectAnswers
                };
            }
        }

        class Enemy {
            constructor(x, y, formulaSystem) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.speed = 80; // pixels per second (slower than player)
                this.maxSpeed = 120;
                
                // Health system
                this.health = 100;
                this.maxHealth = 100;
                
                // AI behavior
                this.targetX = x;
                this.targetY = y;
                this.velocity = { x: 0, y: 0 };
                this.acceleration = 400;
                this.lastDirectionUpdate = 0;
                this.directionUpdateInterval = 100; // Update direction every 100ms
                
                // Visual properties
                this.color = '#ff3300';
                this.glowColor = '#ff330080';
                this.angle = 0;
                this.pulsePhase = Math.random() * Math.PI * 2; // For pulsing effect
                
                // Formula assignment
                this.assignedFormula = formulaSystem.generateFormula();
                this.isTargeted = false; // When player is close enough to see formula
                
                // Status effects
                this.isDead = false;
                this.deathTimer = 0;
                this.deathDuration = 1000; // 1 second death animation
            }

            update(deltaTime, playerX, playerY, canvasWidth, canvasHeight) {
                if (this.isDead) {
                    this.updateDeathAnimation(deltaTime);
                    return;
                }
                
                const dt = deltaTime / 1000;
                
                // Update AI behavior
                this.updateAI(playerX, playerY, deltaTime);
                
                // Update movement
                this.updateMovement(dt);
                
                // Keep within canvas bounds
                this.handleBoundaryCollision(canvasWidth, canvasHeight);
                
                // Update visual effects
                this.pulsePhase += deltaTime * 0.003; // Slow pulsing
                
                // Check if player is close enough to see formula
                const distanceToPlayer = Math.sqrt((this.x - playerX) ** 2 + (this.y - playerY) ** 2);
                this.isTargeted = distanceToPlayer < 100; // Show formula when player is within 100px
            }

            updateAI(playerX, playerY, deltaTime) {
                // Simple AI: Move towards player with some randomness
                const currentTime = Date.now();
                
                if (currentTime - this.lastDirectionUpdate > this.directionUpdateInterval) {
                    // Calculate direction to player with some noise
                    const dx = playerX - this.x;
                    const dy = playerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        // Add some randomness to movement
                        const noise = 0.3;
                        const randomAngle = (Math.random() - 0.5) * noise;
                        const angle = Math.atan2(dy, dx) + randomAngle;
                        
                        this.targetX = this.x + Math.cos(angle) * this.speed;
                        this.targetY = this.y + Math.sin(angle) * this.speed;
                    }
                    
                    this.lastDirectionUpdate = currentTime;
                }
            }

            updateMovement(dt) {
                // Calculate desired velocity towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                let targetVelX = 0;
                let targetVelY = 0;
                
                if (distance > 5) { // Dead zone to prevent jittering
                    targetVelX = (dx / distance) * this.speed;
                    targetVelY = (dy / distance) * this.speed;
                }
                
                // Apply acceleration towards target velocity
                const velDiffX = targetVelX - this.velocity.x;
                const velDiffY = targetVelY - this.velocity.y;
                
                this.velocity.x += velDiffX * this.acceleration * dt;
                this.velocity.y += velDiffY * this.acceleration * dt;
                
                // Limit max speed
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.velocity.x * dt;
                this.y += this.velocity.y * dt;
                
                // Update angle for rotation
                if (Math.abs(this.velocity.x) > 1 || Math.abs(this.velocity.y) > 1) {
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
            }

            updateDeathAnimation(deltaTime) {
                this.deathTimer += deltaTime;
                if (this.deathTimer >= this.deathDuration) {
                    this.isDead = true; // Mark for removal
                }
            }

            handleBoundaryCollision(canvasWidth, canvasHeight) {
                // Bounce off walls
                if (this.x < this.width / 2) {
                    this.x = this.width / 2;
                    this.velocity.x = Math.abs(this.velocity.x) * 0.5;
                }
                if (this.x > canvasWidth - this.width / 2) {
                    this.x = canvasWidth - this.width / 2;
                    this.velocity.x = -Math.abs(this.velocity.x) * 0.5;
                }
                if (this.y < this.height / 2) {
                    this.y = this.height / 2;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.5;
                }
                if (this.y > canvasHeight - this.height / 2) {
                    this.y = canvasHeight - this.height / 2;
                    this.velocity.y = -Math.abs(this.velocity.y) * 0.5;
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.health = 0;
                    this.startDeathAnimation();
                }
            }

            startDeathAnimation() {
                this.isDead = true;
                this.deathTimer = 0;
            }

            isCollidingWith(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.width + other.width) / 2;
            }

            render(ctx) {
                if (this.isDead && this.deathTimer >= this.deathDuration) {
                    return; // Don't render if fully dead
                }
                
                ctx.save();
                
                // Death animation effect
                if (this.isDead) {
                    const deathProgress = this.deathTimer / this.deathDuration;
                    ctx.globalAlpha = 1 - deathProgress;
                    ctx.scale(1 + deathProgress * 0.5, 1 + deathProgress * 0.5);
                }
                
                // Pulsing glow effect
                const pulseIntensity = 0.3 + 0.2 * Math.sin(this.pulsePhase);
                ctx.shadowColor = this.glowColor;
                ctx.shadowBlur = 15 * pulseIntensity;
                
                // Translate to enemy position
                ctx.translate(this.x, this.y);
                
                // Rotate based on movement direction
                ctx.rotate(this.angle);
                
                // Draw enemy body (hexagon for alien look)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i * Math.PI) / 3;
                    const x = Math.cos(angle) * this.width / 2;
                    const y = Math.sin(angle) * this.height / 2;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                // Draw inner core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw health bar
                ctx.restore();
                this.renderHealthBar(ctx);
                
                // Draw formula if player is nearby
                if (this.isTargeted && !this.isDead) {
                    this.renderFormula(ctx);
                }
            }

            renderHealthBar(ctx) {
                if (this.health >= this.maxHealth) return; // Don't show full health
                
                const barWidth = this.width + 10;
                const barHeight = 4;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.height / 2 - 10;
                
                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Health
                const healthPercent = this.health / this.maxHealth;
                const healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillStyle = healthColor;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            renderFormula(ctx) {
                if (!this.assignedFormula) return;
                
                ctx.save();
                
                // Formula background
                const text = this.assignedFormula.text;
                ctx.font = '16px Courier New';
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = 20;
                
                const bgX = this.x - textWidth / 2 - 5;
                const bgY = this.y - this.height / 2 - 35;
                
                // Background with glow
                ctx.shadowColor = '#ff330080';
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bgX, bgY, textWidth + 10, textHeight + 5);
                
                // Border
                ctx.strokeStyle = '#ff3300';
                ctx.lineWidth = 1;
                ctx.strokeRect(bgX, bgY, textWidth + 10, textHeight + 5);
                
                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff3300';
                ctx.textAlign = 'center';
                ctx.fillText(text, this.x, this.y - this.height / 2 - 20);
                
                ctx.restore();
            }

            shouldBeRemoved() {
                return this.isDead && this.deathTimer >= this.deathDuration;
            }

            getDebugInfo() {
                return {
                    position: `(${Math.round(this.x)}, ${Math.round(this.y)})`,
                    health: this.health,
                    formula: this.assignedFormula ? this.assignedFormula.text : 'None',
                    isTargeted: this.isTargeted
                };
            }
        }

        class EnemySpawner {
            constructor(formulaSystem) {
                this.formulaSystem = formulaSystem;
                this.enemies = [];
                this.spawnTimer = 0;
                this.spawnInterval = 3000; // Spawn every 3 seconds
                this.maxEnemies = 5; // Maximum enemies on screen
                this.spawnDistance = 100; // Minimum distance from player to spawn
            }

            update(deltaTime, playerX, playerY, canvasWidth, canvasHeight) {
                this.spawnTimer += deltaTime;
                
                // Spawn new enemies
                if (this.spawnTimer >= this.spawnInterval && this.enemies.length < this.maxEnemies) {
                    this.spawnEnemy(playerX, playerY, canvasWidth, canvasHeight);
                    this.spawnTimer = 0;
                }
                
                // Update all enemies
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    const enemy = this.enemies[i];
                    enemy.update(deltaTime, playerX, playerY, canvasWidth, canvasHeight);
                    
                    // Remove dead enemies
                    if (enemy.shouldBeRemoved()) {
                        this.enemies.splice(i, 1);
                    }
                }
            }

            spawnEnemy(playerX, playerY, canvasWidth, canvasHeight) {
                let spawnX, spawnY;
                let attempts = 0;
                
                // Try to find a spawn position away from player
                do {
                    spawnX = Math.random() * (canvasWidth - 100) + 50;
                    spawnY = Math.random() * (canvasHeight - 100) + 50;
                    const distance = Math.sqrt((spawnX - playerX) ** 2 + (spawnY - playerY) ** 2);
                    
                    if (distance >= this.spawnDistance) {
                        break;
                    }
                    attempts++;
                } while (attempts < 20);
                
                // Create new enemy
                const enemy = new Enemy(spawnX, spawnY, this.formulaSystem);
                this.enemies.push(enemy);
                
                console.log(`Enemy spawned at (${Math.round(spawnX)}, ${Math.round(spawnY)}) with formula: ${enemy.assignedFormula.text}`);
            }

            checkCollisions(player) {
                for (const enemy of this.enemies) {
                    if (!enemy.isDead && enemy.isCollidingWith(player)) {
                        return enemy;
                    }
                }
                return null;
            }

            render(ctx) {
                for (const enemy of this.enemies) {
                    enemy.render(ctx);
                }
            }

            getDebugInfo() {
                return {
                    enemyCount: this.enemies.length,
                    nextSpawn: Math.round((this.spawnInterval - this.spawnTimer) / 1000),
                    enemies: this.enemies.map(e => e.getDebugInfo())
                };
            }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.speed = 200; // pixels per second
                this.maxSpeed = 300;
                
                // Movement state
                this.velocity = { x: 0, y: 0 };
                this.acceleration = 800; // pixels per second squared
                this.friction = 0.85;
                
                // Visual properties
                this.color = '#00ff00';
                this.glowColor = '#00ff0080';
                this.angle = 0; // for rotation effect
            }

            update(deltaTime, inputHandler, canvasWidth, canvasHeight) {
                // Convert deltaTime from milliseconds to seconds
                const dt = deltaTime / 1000;
                
                // Handle input and apply acceleration
                let targetVelX = 0;
                let targetVelY = 0;
                
                if (inputHandler.isPressed('w') || inputHandler.isPressed('W')) {
                    targetVelY = -this.speed;
                }
                if (inputHandler.isPressed('s') || inputHandler.isPressed('S')) {
                    targetVelY = this.speed;
                }
                if (inputHandler.isPressed('a') || inputHandler.isPressed('A')) {
                    targetVelX = -this.speed;
                }
                if (inputHandler.isPressed('d') || inputHandler.isPressed('D')) {
                    targetVelX = this.speed;
                }
                
                // Diagonal movement compensation
                if (targetVelX !== 0 && targetVelY !== 0) {
                    targetVelX *= 0.707; // sqrt(2)/2 for diagonal movement
                    targetVelY *= 0.707;
                }
                
                // Apply acceleration towards target velocity
                const velDiffX = targetVelX - this.velocity.x;
                const velDiffY = targetVelY - this.velocity.y;
                
                this.velocity.x += velDiffX * this.acceleration * dt;
                this.velocity.y += velDiffY * this.acceleration * dt;
                
                // Apply friction when no input
                if (targetVelX === 0 && targetVelY === 0) {
                    this.velocity.x *= this.friction;
                    this.velocity.y *= this.friction;
                }
                
                // Limit max speed
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.velocity.x * dt;
                this.y += this.velocity.y * dt;
                
                // Collision detection with canvas boundaries
                this.handleBoundaryCollision(canvasWidth, canvasHeight);
                
                // Update visual angle for rotation effect
                if (Math.abs(this.velocity.x) > 1 || Math.abs(this.velocity.y) > 1) {
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
            }

            handleBoundaryCollision(canvasWidth, canvasHeight) {
                // Left boundary
                if (this.x < this.width / 2) {
                    this.x = this.width / 2;
                    this.velocity.x = 0;
                }
                // Right boundary
                if (this.x > canvasWidth - this.width / 2) {
                    this.x = canvasWidth - this.width / 2;
                    this.velocity.x = 0;
                }
                // Top boundary
                if (this.y < this.height / 2) {
                    this.y = this.height / 2;
                    this.velocity.y = 0;
                }
                // Bottom boundary
                if (this.y > canvasHeight - this.height / 2) {
                    this.y = canvasHeight - this.height / 2;
                    this.velocity.y = 0;
                }
            }

            render(ctx) {
                ctx.save();
                
                // Draw glow effect
                ctx.shadowColor = this.glowColor;
                ctx.shadowBlur = 15;
                
                // Translate to player position
                ctx.translate(this.x, this.y);
                
                // Rotate based on movement direction
                ctx.rotate(this.angle);
                
                // Draw player body (diamond shape for sci-fi look)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(0, this.height / 2);
                ctx.lineTo(-this.width / 2, 0);
                ctx.lineTo(0, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                
                // Draw center core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw direction indicator
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.width / 2 + 5, 0);
                ctx.stroke();
                
                ctx.restore();
            }

            getDebugInfo() {
                return {
                    position: `(${Math.round(this.x)}, ${Math.round(this.y)})`,
                    velocity: `(${Math.round(this.velocity.x)}, ${Math.round(this.velocity.y)})`,
                    speed: Math.round(Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2))
                };
            }
        }

        class InputHandler {
            constructor() {
                this.keys = {};
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Prevent default behavior for WASD keys
                document.addEventListener('keydown', (e) => {
                    if (['w', 'a', 's', 'd', 'W', 'A', 'S', 'D'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    // Handle SPACE key for formula system
                    if (e.key === ' ' || e.key === 'Space') {
                        e.preventDefault();
                        // This will be handled by GameEngine
                    }
                });
            }

            isPressed(key) {
                return !!this.keys[key];
            }

            isSpacePressed() {
                return this.keys[' '] || this.keys['Space'];
            }

            getDebugInfo() {
                const pressedKeys = Object.keys(this.keys).filter(key => this.keys[key]);
                return pressedKeys.join(', ') || 'None';
            }
        }

        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.fpsCounter = document.getElementById('fpsCounter');
                
                // FPS-Tracking
                this.lastTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.fpsUpdateInterval = 1000; // Update FPS every second
                this.lastFpsUpdate = 0;
                
                // Game state
                this.isRunning = false;
                
                // Game objects
                this.player = null;
                this.inputHandler = null;
                this.formulaSystem = null;
                this.enemySpawner = null;
                
                // Input state tracking
                this.spacePressed = false;
                
                // Game state
                this.playerHealth = 100;
                this.playerMaxHealth = 100;
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.initializeGameObjects();
                this.start();
            }

            initializeGameObjects() {
                // Create input handler
                this.inputHandler = new InputHandler();
                
                // Create player at center of canvas
                this.player = new Player(
                    this.canvas.width / 2,
                    this.canvas.height / 2
                );
                
                // Create formula system
                this.formulaSystem = new FormulaSystem();
                
                // Create enemy spawner
                this.enemySpawner = new EnemySpawner(this.formulaSystem);
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Re-center player if it exists
                if (this.player) {
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });

                // Escape key to potentially pause later
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        console.log('Game paused/resumed');
                    }
                });

                // Focus canvas for keyboard input
                this.canvas.focus();
                this.canvas.setAttribute('tabindex', '0');
            }

            start() {
                this.isRunning = true;
                this.gameLoop();
            }

            stop() {
                this.isRunning = false;
            }

            gameLoop(currentTime = 0) {
                if (!this.isRunning) return;

                // Calculate delta time
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                // Update FPS
                this.updateFPS(currentTime);

                // Update game objects
                this.update(deltaTime);

                // Clear canvas
                this.clearCanvas();

                // Render background
                this.renderBackground();

                // Render game objects
                this.render();

                // Render debug info
                this.renderDebugInfo();

                // Continue game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            updateFPS(currentTime) {
                this.frameCount++;
                
                if (currentTime - this.lastFpsUpdate >= this.fpsUpdateInterval) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    
                    // Update FPS display
                    this.fpsCounter.textContent = `FPS: ${this.fps}`;
                }
            }

            update(deltaTime) {
                // Update player
                if (this.player && this.inputHandler) {
                    this.player.update(deltaTime, this.inputHandler, this.canvas.width, this.canvas.height);
                }
                
                // Update enemies
                if (this.enemySpawner && this.player) {
                    this.enemySpawner.update(deltaTime, this.player.x, this.player.y, this.canvas.width, this.canvas.height);
                }
                
                // Check collisions
                this.handleCollisions();
                
                // Handle SPACE key for formula system
                this.handleFormulaInput();
            }

            handleCollisions() {
                if (!this.player || !this.enemySpawner) return;
                
                const collidingEnemy = this.enemySpawner.checkCollisions(this.player);
                if (collidingEnemy) {
                    // Player takes damage
                    this.playerHealth -= 10;
                    this.playerHealth = Math.max(0, this.playerHealth);
                    
                    // Enemy takes damage (for now, simple damage)
                    collidingEnemy.takeDamage(25);
                    
                    console.log(`Collision! Player health: ${this.playerHealth}, Enemy health: ${collidingEnemy.health}`);
                    
                    // Player death
                    if (this.playerHealth <= 0) {
                        console.log('Player died! Game should restart...');
                        this.playerHealth = this.playerMaxHealth; // Simple respawn for now
                    }
                }
            }

            handleFormulaInput() {
                const spaceCurrentlyPressed = this.inputHandler.isSpacePressed();
                
                // Detect space key press (not held)
                if (spaceCurrentlyPressed && !this.spacePressed) {
                    this.formulaSystem.toggleFormulaHUD();
                }
                
                this.spacePressed = spaceCurrentlyPressed;
            }

            render() {
                // Render enemies first (behind player)
                if (this.enemySpawner) {
                    this.enemySpawner.render(this.ctx);
                }
                
                // Render player
                if (this.player) {
                    this.player.render(this.ctx);
                }
                
                // Render player health bar
                this.renderPlayerHealthBar();
            }

            renderPlayerHealthBar() {
                if (this.playerHealth >= this.playerMaxHealth) return;
                
                const barWidth = 200;
                const barHeight = 8;
                const barX = 10;
                const barY = 120;
                
                // Background
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Health
                const healthPercent = this.playerHealth / this.playerMaxHealth;
                const healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                this.ctx.fillStyle = healthColor;
                this.ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // Border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Text
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '12px Courier New';
                this.ctx.fillText(`Health: ${this.playerHealth}/${this.playerMaxHealth}`, barX, barY - 5);
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            renderBackground() {
                // Create a subtle grid pattern for the dungeon feel
                this.ctx.strokeStyle = '#222';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                
                // Vertical lines
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Add some neon-style corner highlights
                this.ctx.fillStyle = '#00ff0020';
                this.ctx.fillRect(0, 0, 100, 100);
                this.ctx.fillRect(this.canvas.width - 100, 0, 100, 100);
                this.ctx.fillRect(0, this.canvas.height - 100, 100, 100);
                this.ctx.fillRect(this.canvas.width - 100, this.canvas.height - 100, 100, 100);
            }

            renderDebugInfo() {
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '12px Courier New';
                
                const playerDebug = this.player ? this.player.getDebugInfo() : null;
                const inputDebug = this.inputHandler ? this.inputHandler.getDebugInfo() : 'None';
                const formulaDebug = this.formulaSystem ? this.formulaSystem.getDebugInfo() : null;
                const enemyDebug = this.enemySpawner ? this.enemySpawner.getDebugInfo() : null;
                
                const debugInfo = [
                    `Canvas: ${this.canvas.width}x${this.canvas.height}`,
                    `Engine Status: Running`,
                    `Phase: 2.1 - Enemy System`,
                    playerDebug ? `Player Pos: ${playerDebug.position}` : 'Player: None',
                    `Player Health: ${this.playerHealth}/${this.playerMaxHealth}`,
                    formulaDebug ? `Score: ${formulaDebug.score} (${formulaDebug.correct}/${formulaDebug.incorrect})` : '',
                    enemyDebug ? `Enemies: ${enemyDebug.enemyCount}, Next: ${enemyDebug.nextSpawn}s` : 'Enemies: None',
                    `Input: ${inputDebug}`
                ];
                
                debugInfo.forEach((info, index) => {
                    if (info) { // Only render non-empty strings
                        this.ctx.fillText(info, 10, this.canvas.height - 105 + (index * 15));
                    }
                });
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            console.log('🎮 Formel-Fury-Shooter initializing...');
            const game = new GameEngine();
            console.log('✅ Game engine started successfully!');
            
            // Make game accessible globally for debugging
            window.game = game;
        });
    </script>
</body>
</html>
