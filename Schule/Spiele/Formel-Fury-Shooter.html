<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formel-Fury-Shooter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameCanvas {
            display: block;
            background-color: #111;
            cursor: crosshair;
        }

        #fpsCounter {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        #gameInfo {
            position: absolute;
            top: 10px;
            right: 10px;
            color: #00ff00;
            font-size: 14px;
            text-align: right;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            z-index: 100;
        }

        /* Game UI System */
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 200;
        }

        #formulaHUD {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #001a00, #003300);
            border: 2px solid #00ff00;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 
                0 0 20px #00ff0080,
                inset 0 0 20px #00ff0020;
            pointer-events: auto;
            display: none;
            min-width: 400px;
            text-align: center;
        }

        #formulaDisplay {
            background: #000;
            border: 1px solid #00ff00;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            color: #00ff00;
            text-shadow: 0 0 10px #00ff0080;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #formulaInput {
            width: 100%;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 12px;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            color: #00ff00;
            text-shadow: 0 0 5px #00ff0080;
            outline: none;
            margin-bottom: 15px;
        }

        #formulaInput:focus {
            box-shadow: 0 0 15px #00ff00;
            border-color: #00ff88;
        }

        #formulaInput::placeholder {
            color: #00ff0060;
        }

        #formulaButtons {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .formula-btn {
            background: linear-gradient(145deg, #003300, #006600);
            border: 1px solid #00ff00;
            border-radius: 6px;
            padding: 8px 16px;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            text-shadow: 0 0 5px #00ff0080;
        }

        .formula-btn:hover {
            background: linear-gradient(145deg, #006600, #009900);
            box-shadow: 0 0 10px #00ff0060;
        }

        .formula-btn:active {
            transform: scale(0.95);
        }

        #feedbackDisplay {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 25px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            display: none;
            z-index: 300;
            animation: feedbackPulse 0.5s ease-out;
        }

        .feedback-correct {
            background: linear-gradient(145deg, #003300, #006600);
            color: #00ff00;
            border: 2px solid #00ff00;
            box-shadow: 0 0 20px #00ff0080;
        }

        .feedback-incorrect {
            background: linear-gradient(145deg, #330000, #660000);
            color: #ff0000;
            border: 2px solid #ff0000;
            box-shadow: 0 0 20px #ff000080;
        }

        @keyframes feedbackPulse {
            0% { transform: translateX(-50%) scale(0.8); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); opacity: 1; }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

                 #scoreDisplay {
             position: absolute;
             top: 80px;
             left: 10px;
             color: #00ff00;
             font-size: 16px;
             font-weight: bold;
             text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
             z-index: 100;
         }

         #comboDisplay {
             position: absolute;
             top: 80px;
             right: 10px;
             color: #ffff00;
             font-size: 16px;
             font-weight: bold;
             text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
             z-index: 100;
             text-align: right;
         }

         .combo-active {
             color: #ff6600 !important;
             text-shadow: 0 0 10px #ff660080 !important;
             animation: comboGlow 0.5s ease-in-out infinite alternate;
         }

         @keyframes comboGlow {
             0% { text-shadow: 0 0 10px #ff660080; }
             100% { text-shadow: 0 0 20px #ff6600ff; }
         }

         #highScoreDisplay {
             position: absolute;
             top: 10px;
             left: 50%;
             transform: translateX(-50%);
             color: #00ffff;
             font-size: 14px;
             font-weight: bold;
             text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
             z-index: 100;
             text-align: center;
         }

        /* Pause Menu System */
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        #pauseContent {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(145deg, #001a00, #003300);
            border: 3px solid #00ff00;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 
                0 0 30px #00ff0080,
                inset 0 0 30px #00ff0020;
            text-align: center;
            min-width: 400px;
        }

        #pauseTitle {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 36px;
            font-weight: bold;
            text-shadow: 0 0 20px #00ff0080;
            margin-bottom: 30px;
            animation: pausePulse 2s ease-in-out infinite alternate;
        }

        @keyframes pausePulse {
            0% { text-shadow: 0 0 20px #00ff0080; }
            100% { text-shadow: 0 0 30px #00ff00ff; }
        }

        .pause-btn {
            display: block;
            width: 100%;
            background: linear-gradient(145deg, #003300, #006600);
            border: 2px solid #00ff00;
            border-radius: 10px;
            padding: 15px 20px;
            margin: 15px 0;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-shadow: 0 0 10px #00ff0080;
        }

        .pause-btn:hover {
            background: linear-gradient(145deg, #006600, #009900);
            box-shadow: 0 0 20px #00ff0060;
            transform: scale(1.05);
        }

        .pause-btn:active {
            transform: scale(0.95);
        }

        #pauseStats {
            margin-top: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            border-radius: 10px;
        }

        .pause-stat {
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
        }

        .pause-warning {
            color: #ffff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin-top: 20px;
            padding: 10px;
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Game UI Overlay -->
    <div id="gameUI">
        <!-- Formula Challenge HUD -->
        <div id="formulaHUD">
            <div id="formulaDisplay">Dr√ºcke SPACE f√ºr eine neue Formel...</div>
            <input type="text" id="formulaInput" placeholder="Gib die L√∂sung ein... (z.B. x¬≤ + 4x + 4)" />
            <div id="formulaButtons">
                <button class="formula-btn" onclick="game.formulaSystem.submitAnswer()">Antworten</button>
                <button class="formula-btn" onclick="game.formulaSystem.skipFormula()">√úberspringen</button>
                <button class="formula-btn" onclick="game.formulaSystem.hideFormulaHUD()">Schlie√üen</button>
            </div>
        </div>
        
        <!-- Feedback Display -->
        <div id="feedbackDisplay"></div>
    </div>

    <!-- Pause Menu -->
    <div id="pauseMenu">
        <div id="pauseContent">
            <div id="pauseTitle">SPIEL PAUSIERT</div>
            
            <button class="pause-btn" onclick="game.resumeGame()">
                ‚ñ∂ Spiel Fortsetzen
            </button>
            
            <button class="pause-btn" onclick="game.restartGame()">
                üîÑ Neustart
            </button>
            
            <button class="pause-btn" onclick="game.togglePauseMenu()">
                ‚öô Zur√ºck zum Spiel
            </button>
            
            <div id="pauseStats">
                <div class="pause-stat">
                    <span>Aktuelle Punktzahl:</span>
                    <span id="pauseScore">0</span>
                </div>
                <div class="pause-stat">
                    <span>Richtige Antworten:</span>
                    <span id="pauseCorrect">0</span>
                </div>
                <div class="pause-stat">
                    <span>Falsche Antworten:</span>
                    <span id="pauseIncorrect">0</span>
                </div>
                <div class="pause-stat">
                    <span>Genauigkeit:</span>
                    <span id="pauseAccuracy">100%</span>
                </div>
                <div class="pause-stat">
                    <span>Aktuelle Gesundheit:</span>
                    <span id="pauseHealth">100/100</span>
                </div>
            </div>
            
            <div class="pause-warning">
                ‚ö† Formeln und Antworten sind im Pause-Men√º verborgen ‚ö†<br>
                Dies verhindert unfaires Nachschlagen w√§hrend des Spiels.
            </div>
        </div>
    </div>
    
    <!-- HUD Elements -->
    <div id="fpsCounter">FPS: 0</div>
         <div id="scoreDisplay">
         <div>Score: <span id="scoreValue">0</span></div>
         <div>Richtig: <span id="correctCount">0</span></div>
         <div>Falsch: <span id="incorrectCount">0</span></div>
     </div>
     
     <div id="comboDisplay">
         <div>Combo: <span id="comboValue">0</span></div>
         <div>Max: <span id="comboMaxValue">0</span></div>
         <div>‚è± Zeit: <span id="comboTimer">10</span>s</div>
     </div>
     
     <div id="highScoreDisplay">
         <div>üèÜ High Score: <span id="highScoreValue">0</span></div>
     </div>
     
              <div id="gameInfo">
             <div>Formel-Fury-Shooter v0.9</div>
             <div>Phase 3.2: Enemy-Typen</div>
             <div>Controls: WASD + Maus + ESC | PZ/GG/EB = Enemy-Typen!</div>
         </div>

    <script>
                 class FormulaSystem {
             constructor() {
                 this.currentFormula = null;
                 this.currentSolution = null;
                 this.score = 0;
                 this.correctAnswers = 0;
                 this.incorrectAnswers = 0;
                 
                 // Combo system
                 this.combo = 0;
                 this.maxCombo = 0;
                 this.comboStartTime = 0;
                 this.comboTimeLimit = 10000; // 10 seconds per combo
                 this.lastAnswerTime = 0;
                 
                 // Scoring system
                 this.baseScore = 100;
                 this.comboMultiplier = 1.5;
                 this.speedBonus = 50;
                 this.combatBonus = 50;
                 
                 // UI Elements
                 this.formulaHUD = document.getElementById('formulaHUD');
                 this.formulaDisplay = document.getElementById('formulaDisplay');
                 this.formulaInput = document.getElementById('formulaInput');
                 this.feedbackDisplay = document.getElementById('feedbackDisplay');
                 this.scoreValue = document.getElementById('scoreValue');
                 this.correctCount = document.getElementById('correctCount');
                 this.incorrectCount = document.getElementById('incorrectCount');
                 
                 // Initialize high score
                 this.highScore = this.loadHighScore();
                 
                 // Additional UI elements
                 this.comboElement = document.getElementById('comboValue');
                 this.comboMaxElement = document.getElementById('comboMaxValue');
                 this.comboTimerElement = document.getElementById('comboTimer');
                 this.highScoreElement = document.getElementById('highScoreValue');
                 
                 this.setupEventListeners();
                 this.generateFormula();
                 this.startComboTimer();
                 this.updateHighScoreDisplay();
             }

            setupEventListeners() {
                // Enter key to submit answer
                this.formulaInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        this.submitAnswer();
                    }
                });
            }

                         generateFormula() {
                 // Select formula type based on difficulty progression
                 const formulaTypes = [
                     'expansion_plus',    // (a+b)¬≤ = a¬≤ + 2ab + b¬≤
                     'expansion_minus',   // (a-b)¬≤ = a¬≤ - 2ab + b¬≤
                     'difference_squares', // (a+b)(a-b) = a¬≤ - b¬≤
                     'factorization_difference', // a¬≤ - b¬≤ = (a+b)(a-b)
                     'factorization_square' // a¬≤ + 2ab + b¬≤ = (a+b)¬≤
                 ];
                 
                 // Progressive difficulty: start with simple, add complexity over time
                 const availableTypes = this.getAvailableFormulaTypes(formulaTypes);
                 const selectedType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
                 
                 return this.generateFormulaByType(selectedType);
             }

             getAvailableFormulaTypes(allTypes) {
                 // Progressive unlock based on score/combo
                 const baseTypes = ['expansion_plus'];
                 
                 if (this.score >= 500 || this.maxCombo >= 3) {
                     baseTypes.push('expansion_minus');
                 }
                 
                 if (this.score >= 1000 || this.maxCombo >= 5) {
                     baseTypes.push('difference_squares');
                 }
                 
                 if (this.score >= 1500 || this.maxCombo >= 8) {
                     baseTypes.push('factorization_difference');
                 }
                 
                 if (this.score >= 2000 || this.maxCombo >= 10) {
                     baseTypes.push('factorization_square');
                 }
                 
                 return baseTypes;
             }

             generateFormulaByType(type) {
                 switch (type) {
                     case 'expansion_plus':
                         return this.generateExpansionPlus();
                     case 'expansion_minus':
                         return this.generateExpansionMinus();
                     case 'difference_squares':
                         return this.generateDifferenceSquares();
                     case 'factorization_difference':
                         return this.generateFactorizationDifference();
                     case 'factorization_square':
                         return this.generateFactorizationSquare();
                     default:
                         return this.generateExpansionPlus();
                 }
             }

             generateExpansionPlus() {
                 const variables = ['x', 'y', 'z', 'a', 'b', 'c'];
                 const variable = variables[Math.floor(Math.random() * variables.length)];
                 
                 // Generate coefficients with variety
                 const a = this.generateCoefficient();
                 const b = this.generateConstant();
                 
                 const formulaText = `(${this.formatTerm(a, variable)} + ${b})¬≤`;
                 
                 // Calculate solution: (ax + b)¬≤ = a¬≤x¬≤ + 2abx + b¬≤
                 const coefficient_x2 = a * a;
                 const coefficient_x = 2 * a * b;
                 const constant = b * b;
                 
                 const formula = {
                     text: formulaText,
                     type: 'expansion_plus',
                     typeName: 'Erste Binomische Formel',
                     a: a,
                     b: b,
                     variable: variable,
                     difficulty: this.calculateDifficulty(a, b, coefficient_x2, coefficient_x, constant),
                     coefficients: {
                         x2: coefficient_x2,
                         x: coefficient_x,
                         constant: constant
                     }
                 };
                 
                 formula.solutions = this.generateExpansionSolutions(coefficient_x2, coefficient_x, constant, variable);
                 this.updateCurrentFormula(formula);
                 return formula;
             }

             generateExpansionMinus() {
                 const variables = ['x', 'y', 'z', 'a', 'b', 'c'];
                 const variable = variables[Math.floor(Math.random() * variables.length)];
                 
                 const a = this.generateCoefficient();
                 const b = this.generateConstant();
                 
                 const formulaText = `(${this.formatTerm(a, variable)} - ${b})¬≤`;
                 
                 // Calculate solution: (ax - b)¬≤ = a¬≤x¬≤ - 2abx + b¬≤
                 const coefficient_x2 = a * a;
                 const coefficient_x = -2 * a * b; // Negative middle term
                 const constant = b * b;
                 
                 const formula = {
                     text: formulaText,
                     type: 'expansion_minus',
                     typeName: 'Zweite Binomische Formel',
                     a: a,
                     b: b,
                     variable: variable,
                     difficulty: this.calculateDifficulty(a, b, coefficient_x2, Math.abs(coefficient_x), constant),
                     coefficients: {
                         x2: coefficient_x2,
                         x: coefficient_x,
                         constant: constant
                     }
                 };
                 
                 formula.solutions = this.generateExpansionSolutions(coefficient_x2, coefficient_x, constant, variable);
                 this.updateCurrentFormula(formula);
                 return formula;
             }

             generateDifferenceSquares() {
                 const variables = ['x', 'y', 'z', 'a', 'b', 'c'];
                 const variable = variables[Math.floor(Math.random() * variables.length)];
                 
                 const a = this.generateCoefficient();
                 const b = this.generateConstant();
                 
                 const formulaText = `(${this.formatTerm(a, variable)} + ${b})(${this.formatTerm(a, variable)} - ${b})`;
                 
                 // Calculate solution: (ax + b)(ax - b) = a¬≤x¬≤ - b¬≤
                 const coefficient_x2 = a * a;
                 const coefficient_x = 0; // No middle term
                 const constant = -(b * b); // Negative constant
                 
                 const formula = {
                     text: formulaText,
                     type: 'difference_squares',
                     typeName: 'Dritte Binomische Formel',
                     a: a,
                     b: b,
                     variable: variable,
                     difficulty: this.calculateDifficulty(a, b, coefficient_x2, 0, Math.abs(constant)) + 0.5,
                     coefficients: {
                         x2: coefficient_x2,
                         x: coefficient_x,
                         constant: constant
                     }
                 };
                 
                 formula.solutions = this.generateDifferenceSquaresSolutions(coefficient_x2, constant, variable);
                 this.updateCurrentFormula(formula);
                 return formula;
             }

             generateFactorizationDifference() {
                 const variables = ['x', 'y', 'z', 'a', 'b', 'c'];
                 const variable = variables[Math.floor(Math.random() * variables.length)];
                 
                 const a = this.generateCoefficient();
                 const b = this.generateConstant();
                 
                 // Start with expanded form: a¬≤x¬≤ - b¬≤
                 const coefficient_x2 = a * a;
                 const constant = -(b * b);
                 
                 const formulaText = `${this.formatQuadraticTerm(coefficient_x2, variable)} ${constant >= 0 ? '+' : '-'} ${Math.abs(constant)}`;
                 
                 const formula = {
                     text: formulaText,
                     type: 'factorization_difference',
                     typeName: 'Faktorisierung (Differenz)',
                     a: a,
                     b: b,
                     variable: variable,
                     difficulty: this.calculateDifficulty(a, b, coefficient_x2, 0, Math.abs(constant)) + 1.0,
                     coefficients: {
                         x2: coefficient_x2,
                         x: 0,
                         constant: constant
                     }
                 };
                 
                 formula.solutions = this.generateFactorizationDifferenceSolutions(a, b, variable);
                 this.updateCurrentFormula(formula);
                 return formula;
             }

             generateFactorizationSquare() {
                 const variables = ['x', 'y', 'z', 'a', 'b', 'c'];
                 const variable = variables[Math.floor(Math.random() * variables.length)];
                 
                 const a = this.generateCoefficient();
                 const b = this.generateConstant();
                 
                 // Start with expanded form: a¬≤x¬≤ + 2abx + b¬≤
                 const coefficient_x2 = a * a;
                 const coefficient_x = 2 * a * b;
                 const constant = b * b;
                 
                 const formulaText = this.formatExpandedForm(coefficient_x2, coefficient_x, constant, variable);
                 
                 const formula = {
                     text: formulaText,
                     type: 'factorization_square',
                     typeName: 'Faktorisierung (Quadrat)',
                     a: a,
                     b: b,
                     variable: variable,
                     difficulty: this.calculateDifficulty(a, b, coefficient_x2, coefficient_x, constant) + 1.5,
                     coefficients: {
                         x2: coefficient_x2,
                         x: coefficient_x,
                         constant: constant
                     }
                 };
                 
                 formula.solutions = this.generateFactorizationSquareSolutions(a, b, variable);
                 this.updateCurrentFormula(formula);
                 return formula;
             }

             // Helper methods for coefficient generation
             generateCoefficient() {
                 // Progressive difficulty based on score
                 if (this.score < 500) return Math.floor(Math.random() * 3) + 1; // 1-3
                 if (this.score < 1500) return Math.floor(Math.random() * 5) + 1; // 1-5
                 return Math.floor(Math.random() * 7) + 1; // 1-7
             }

             generateConstant() {
                 if (this.score < 500) return Math.floor(Math.random() * 4) + 1; // 1-4
                 if (this.score < 1500) return Math.floor(Math.random() * 6) + 1; // 1-6
                 return Math.floor(Math.random() * 10) + 1; // 1-10
             }

             formatTerm(coefficient, variable) {
                 if (coefficient === 1) return variable;
                 return `${coefficient}${variable}`;
             }

             formatQuadraticTerm(coefficient, variable) {
                 if (coefficient === 1) return `${variable}¬≤`;
                 return `${coefficient}${variable}¬≤`;
             }

             formatExpandedForm(a2, a1, a0, variable) {
                 let result = this.formatQuadraticTerm(a2, variable);
                 
                 if (a1 > 0) {
                     result += ` + ${a1 === 1 ? variable : a1 + variable}`;
                 } else if (a1 < 0) {
                     result += ` - ${Math.abs(a1) === 1 ? variable : Math.abs(a1) + variable}`;
                 }
                 
                 if (a0 > 0) {
                     result += ` + ${a0}`;
                 } else if (a0 < 0) {
                     result += ` - ${Math.abs(a0)}`;
                 }
                 
                 return result;
             }

             updateCurrentFormula(formula) {
                 this.currentFormula = formula;
                 this.currentSolution = formula.solutions;
                 
                 console.log(`Generated ${formula.typeName}:`, formula.text);
                 console.log('Expected solutions:', formula.solutions);
             }

             calculateDifficulty(a, b, x2, x, constant) {
                 // Base difficulty factors
                 let difficulty = 1;
                 
                 // Coefficient complexity
                 if (a >= 4 || b >= 4) difficulty += 0.5;
                 if (a >= 6 || b >= 8) difficulty += 0.5;
                 
                 // Result complexity  
                 if (x2 >= 16) difficulty += 0.5; // 4¬≤ or higher
                 if (Math.abs(x) >= 20) difficulty += 0.5; // Large middle terms
                 if (Math.abs(constant) >= 25) difficulty += 0.5; // Large constants
                 
                 // Very complex combinations
                 if (x2 > 25 && Math.abs(x) > 30) difficulty += 1;
                 if (Math.abs(constant) > 36) difficulty += 0.5;
                 
                 // Formula type bonus (added by specific generators)
                 // expansion_plus: +0 (base)
                 // expansion_minus: +0 (same complexity)
                 // difference_squares: +0.5 (conceptually harder)
                 // factorization_*: +1.0-1.5 (reverse thinking)
                 
                 return Math.max(1, Math.min(5, difficulty)); // Extended range 1-5
             }

             startComboTimer() {
                 this.comboStartTime = Date.now();
                 this.lastAnswerTime = Date.now();
             }

             updateComboTimer() {
                 const currentTime = Date.now();
                 const timeSinceLastAnswer = currentTime - this.lastAnswerTime;
                 
                 // Break combo if too much time has passed
                 if (this.combo > 0 && timeSinceLastAnswer > this.comboTimeLimit) {
                     this.breakCombo('Zeit abgelaufen!');
                 }
             }

             incrementCombo() {
                 this.combo++;
                 if (this.combo > this.maxCombo) {
                     this.maxCombo = this.combo;
                 }
                 this.lastAnswerTime = Date.now();
                 
                 // Show combo feedback
                 if (this.combo >= 3) {
                     this.showComboFeedback();
                 }
             }

             breakCombo(reason = 'Falsche Antwort!') {
                 if (this.combo >= 3) {
                     this.showFeedback(`Combo gebrochen! ${reason} (Combo: ${this.combo})`, false);
                 }
                 this.combo = 0;
                 this.lastAnswerTime = Date.now();
             }

             showComboFeedback() {
                 const comboMessages = {
                     3: 'Combo x3! üî•',
                     5: 'Combo x5! ‚ö°',
                     7: 'Combo x7! üí´',
                     10: 'Combo x10! üåü',
                     15: 'MEGA COMBO x15! üí•',
                     20: 'ULTRA COMBO x20! üöÄ'
                 };
                 
                 const message = comboMessages[this.combo] || `Combo x${this.combo}! üéØ`;
                 this.showFeedback(message, true);
             }

             calculateScore(formula, timeTaken, isCombat = false) {
                 let score = this.baseScore;
                 
                 // Difficulty multiplier
                 score *= formula.difficulty;
                 
                 // Combo multiplier
                 if (this.combo >= 3) {
                     score *= (1 + (this.combo - 1) * 0.2); // 20% per combo level after 3
                 }
                 
                 // Speed bonus (under 5 seconds = bonus)
                 if (timeTaken < 5000) {
                     const speedMultiplier = Math.max(0.5, (5000 - timeTaken) / 5000);
                     score += this.speedBonus * speedMultiplier;
                 }
                 
                 // Combat bonus
                 if (isCombat) {
                     score += this.combatBonus;
                 }
                 
                 return Math.round(score);
             }

                         generateExpansionSolutions(a2, a1, a0, variable) {
                 const solutions = [];
                 
                 // Standard expanded form
                 const x2_term = a2 === 1 ? `${variable}¬≤` : `${a2}${variable}¬≤`;
                 const x2_term_alt = a2 === 1 ? `${variable}^2` : `${a2}${variable}^2`;
                 
                 // Handle middle term
                 let middleTerm = '';
                 let middleTermAlt = '';
                 if (a1 > 0) {
                     middleTerm = a1 === 1 ? ` + ${variable}` : ` + ${a1}${variable}`;
                     middleTermAlt = middleTerm;
                 } else if (a1 < 0) {
                     middleTerm = Math.abs(a1) === 1 ? ` - ${variable}` : ` - ${Math.abs(a1)}${variable}`;
                     middleTermAlt = middleTerm;
                 }
                 
                 // Handle constant term
                 const constantTerm = a0 > 0 ? ` + ${a0}` : (a0 < 0 ? ` - ${Math.abs(a0)}` : '');
                 
                 // Main solutions
                 solutions.push(`${x2_term}${middleTerm}${constantTerm}`);
                 solutions.push(`${x2_term_alt}${middleTermAlt}${constantTerm}`);
                 
                 // With spaces
                 const x2_spaced = a2 === 1 ? `${variable}¬≤` : `${a2} ${variable}¬≤`;
                 const x2_spaced_alt = a2 === 1 ? `${variable}^2` : `${a2} ${variable}^2`;
                 
                 let middleSpaced = '';
                 if (a1 > 0) {
                     middleSpaced = a1 === 1 ? ` + ${variable}` : ` + ${a1} ${variable}`;
                 } else if (a1 < 0) {
                     middleSpaced = Math.abs(a1) === 1 ? ` - ${variable}` : ` - ${Math.abs(a1)} ${variable}`;
                 }
                 
                 solutions.push(`${x2_spaced}${middleSpaced}${constantTerm}`);
                 solutions.push(`${x2_spaced_alt}${middleSpaced}${constantTerm}`);
                 
                 // Different order variations
                 if (a1 !== 0 && a0 !== 0) {
                     solutions.push(`${x2_term}${constantTerm}${middleTerm}`);
                     solutions.push(`${x2_term_alt}${constantTerm}${middleTermAlt}`);
                 }
                 
                 return [...new Set(solutions)]; // Remove duplicates
             }

             generateDifferenceSquaresSolutions(a2, constant, variable) {
                 const solutions = [];
                 
                 // a¬≤x¬≤ - b¬≤ format
                 const x2_term = a2 === 1 ? `${variable}¬≤` : `${a2}${variable}¬≤`;
                 const x2_term_alt = a2 === 1 ? `${variable}^2` : `${a2}${variable}^2`;
                 
                 const constantTerm = constant < 0 ? ` - ${Math.abs(constant)}` : ` + ${constant}`;
                 
                 solutions.push(`${x2_term}${constantTerm}`);
                 solutions.push(`${x2_term_alt}${constantTerm}`);
                 
                 // With spaces
                 const x2_spaced = a2 === 1 ? `${variable}¬≤` : `${a2} ${variable}¬≤`;
                 const x2_spaced_alt = a2 === 1 ? `${variable}^2` : `${a2} ${variable}^2`;
                 
                 solutions.push(`${x2_spaced}${constantTerm}`);
                 solutions.push(`${x2_spaced_alt}${constantTerm}`);
                 
                 return [...new Set(solutions)];
             }

             generateFactorizationDifferenceSolutions(a, b, variable) {
                 const solutions = [];
                 
                 // (ax + b)(ax - b) format
                 const term1 = a === 1 ? variable : `${a}${variable}`;
                 const term2 = a === 1 ? variable : `${a}${variable}`;
                 
                 solutions.push(`(${term1} + ${b})(${term2} - ${b})`);
                 solutions.push(`(${term2} - ${b})(${term1} + ${b})`); // Commutative
                 
                 // With spaces
                 solutions.push(`(${term1} + ${b}) (${term2} - ${b})`);
                 solutions.push(`(${term2} - ${b}) (${term1} + ${b})`);
                 
                 // Alternative notation
                 solutions.push(`(${term1}+${b})(${term2}-${b})`);
                 solutions.push(`(${term2}-${b})(${term1}+${b})`);
                 
                 return [...new Set(solutions)];
             }

             generateFactorizationSquareSolutions(a, b, variable) {
                 const solutions = [];
                 
                 // Determine if it's (a+b)¬≤ or (a-b)¬≤ based on middle term
                 const middleCoeff = 2 * a * b;
                 const term = a === 1 ? variable : `${a}${variable}`;
                 
                 if (middleCoeff > 0) {
                     // (ax + b)¬≤
                     solutions.push(`(${term} + ${b})¬≤`);
                     solutions.push(`(${term} + ${b})^2`);
                     solutions.push(`(${term}+${b})¬≤`);
                     solutions.push(`(${term}+${b})^2`);
                 } else {
                     // (ax - b)¬≤
                     solutions.push(`(${term} - ${b})¬≤`);
                     solutions.push(`(${term} - ${b})^2`);
                     solutions.push(`(${term}-${b})¬≤`);
                     solutions.push(`(${term}-${b})^2`);
                 }
                 
                 return [...new Set(solutions)];
             }

                         normalizeExpression(expr) {
                 return expr
                     .toLowerCase()
                     .replace(/\s+/g, '') // Remove all spaces
                     .replace(/\^2/g, '¬≤') // Convert ^2 to ¬≤
                     .replace(/\*([xyzabc])/g, '$1') // Remove * before variables
                     .replace(/([xyzabc])\*/g, '$1') // Remove * after variables
                     .replace(/\+\+/g, '+') // Fix double plus
                     .replace(/--/g, '+') // Convert -- to +
                     .replace(/\+-/g, '-') // Convert +- to -
                     .replace(/-\+/g, '-') // Convert -+ to -
                     .replace(/\(\s*([^)]+)\s*\)/g, '($1)') // Normalize parentheses
                     .replace(/([0-9])([xyzabc])/g, '$1$2') // Ensure no space between coefficient and variable
                     .replace(/\+1([xyzabc])/g, '+$1') // Simplify +1x to +x
                     .replace(/^1([xyzabc])/g, '$1') // Simplify 1x to x at start
                     .replace(/-1([xyzabc])/g, '-$1'); // Simplify -1x to -x
             }

                         validateAnswer(userInput) {
                 const normalizedInput = this.normalizeExpression(userInput);
                 
                 // Direct solution match
                 for (let solution of this.currentSolution) {
                     const normalizedSolution = this.normalizeExpression(solution);
                     if (normalizedInput === normalizedSolution) {
                         return true;
                     }
                 }
                 
                 // Type-specific validation
                 return this.validateByFormulaType(normalizedInput);
             }

             validateByFormulaType(normalizedInput) {
                 const formula = this.currentFormula;
                 
                 switch (formula.type) {
                     case 'expansion_plus':
                     case 'expansion_minus':
                         return this.validateExpansion(normalizedInput);
                     case 'difference_squares':
                         return this.validateDifferenceSquares(normalizedInput);
                     case 'factorization_difference':
                         return this.validateFactorizationDifference(normalizedInput);
                     case 'factorization_square':
                         return this.validateFactorizationSquare(normalizedInput);
                     default:
                         return this.validateExpansion(normalizedInput);
                 }
             }

             validateExpansion(normalizedInput) {
                 const { x2, x, constant } = this.currentFormula.coefficients;
                 const variable = this.currentFormula.variable;
                 
                 // Check for all required terms
                 const hasX2Term = this.checkQuadraticTerm(normalizedInput, x2, variable);
                 const hasXTerm = x === 0 || this.checkLinearTerm(normalizedInput, x, variable);
                 const hasConstantTerm = constant === 0 || this.checkConstantTerm(normalizedInput, constant);
                 
                 return hasX2Term && hasXTerm && hasConstantTerm;
             }

             validateDifferenceSquares(normalizedInput) {
                 const { x2, constant } = this.currentFormula.coefficients;
                 const variable = this.currentFormula.variable;
                 
                 const hasX2Term = this.checkQuadraticTerm(normalizedInput, x2, variable);
                 const hasConstantTerm = this.checkConstantTerm(normalizedInput, constant);
                 
                 // Should NOT have linear term
                 const hasNoLinearTerm = !this.hasLinearTerm(normalizedInput, variable);
                 
                 return hasX2Term && hasConstantTerm && hasNoLinearTerm;
             }

             validateFactorizationDifference(normalizedInput) {
                 const { a, b } = this.currentFormula;
                 const variable = this.currentFormula.variable;
                 
                 // Should be in form (ax+b)(ax-b) or (ax-b)(ax+b)
                 const pattern1 = this.normalizeExpression(`(${a === 1 ? variable : a + variable}+${b})(${a === 1 ? variable : a + variable}-${b})`);
                 const pattern2 = this.normalizeExpression(`(${a === 1 ? variable : a + variable}-${b})(${a === 1 ? variable : a + variable}+${b})`);
                 
                 return normalizedInput === pattern1 || normalizedInput === pattern2;
             }

             validateFactorizationSquare(normalizedInput) {
                 const { a, b } = this.currentFormula;
                 const variable = this.currentFormula.variable;
                 const middleCoeff = 2 * a * b;
                 
                 if (middleCoeff > 0) {
                     // Should be (ax+b)¬≤
                     const pattern = this.normalizeExpression(`(${a === 1 ? variable : a + variable}+${b})¬≤`);
                     return normalizedInput === pattern;
                 } else {
                     // Should be (ax-b)¬≤
                     const pattern = this.normalizeExpression(`(${a === 1 ? variable : a + variable}-${b})¬≤`);
                     return normalizedInput === pattern;
                 }
             }

             // Helper validation methods
             checkQuadraticTerm(input, expectedCoeff, variable) {
                 if (expectedCoeff === 1) {
                     return input.includes(`${variable}¬≤`) || input.includes(`${variable}^2`);
                 }
                 return input.includes(`${expectedCoeff}${variable}¬≤`) || input.includes(`${expectedCoeff}${variable}^2`);
             }

             checkLinearTerm(input, expectedCoeff, variable) {
                 if (expectedCoeff === 1) {
                     return input.includes(`+${variable}`) || input.includes(`${variable}+`) || 
                            (input.includes(variable) && !input.includes(`${variable}¬≤`) && !input.includes(`${variable}^2`));
                 } else if (expectedCoeff === -1) {
                     return input.includes(`-${variable}`);
                 } else if (expectedCoeff > 0) {
                     return input.includes(`+${expectedCoeff}${variable}`) || input.includes(`${expectedCoeff}${variable}`);
                 } else {
                     return input.includes(`${expectedCoeff}${variable}`) || input.includes(`-${Math.abs(expectedCoeff)}${variable}`);
                 }
             }

             checkConstantTerm(input, expectedConstant) {
                 if (expectedConstant > 0) {
                     return input.includes(`+${expectedConstant}`) || input.includes(`${expectedConstant}`);
                 } else {
                     return input.includes(`${expectedConstant}`) || input.includes(`-${Math.abs(expectedConstant)}`);
                 }
             }

             hasLinearTerm(input, variable) {
                 // Check if input contains linear term (variable without ¬≤)
                 const regex = new RegExp(`\\d*${variable}(?![¬≤^2])`, 'g');
                 return regex.test(input);
             }

            submitAnswer() {
                const userAnswer = this.formulaInput.value.trim();
                
                if (!userAnswer) {
                    this.showFeedback('Bitte gib eine Antwort ein!', false);
                    return;
                }
                
                const isCorrect = this.validateAnswer(userAnswer);
                
                if (isCorrect) {
                    this.correctAnswers++;
                    this.score += 100;
                    this.showFeedback('Richtig! +100 Punkte', true);
                } else {
                    this.incorrectAnswers++;
                    this.score = Math.max(0, this.score - 25);
                    this.showFeedback(`Falsch! Richtig w√§re: ${this.currentSolution[0]}`, false);
                }
                
                this.updateScoreDisplay();
                this.formulaInput.value = '';
                
                // Generate new formula after a delay
                setTimeout(() => {
                    this.generateFormula();
                    this.showFormulaHUD();
                }, 2000);
            }

            skipFormula() {
                this.showFeedback(`√úbersprungen! L√∂sung war: ${this.currentSolution[0]}`, false);
                this.formulaInput.value = '';
                
                setTimeout(() => {
                    this.generateFormula();
                    this.showFormulaHUD();
                }, 1500);
            }

            showFeedback(message, isCorrect) {
                this.feedbackDisplay.textContent = message;
                this.feedbackDisplay.className = isCorrect ? 'feedback-correct' : 'feedback-incorrect';
                this.feedbackDisplay.style.display = 'block';
                
                setTimeout(() => {
                    this.feedbackDisplay.style.display = 'none';
                }, 2000);
            }

                         updateScoreDisplay() {
                 this.scoreValue.textContent = this.score;
                 this.correctCount.textContent = this.correctAnswers;
                 this.incorrectCount.textContent = this.incorrectAnswers;
                 
                 // Update combo display
                 this.updateComboDisplay();
                 
                 // Check and update high score
                 if (this.score > this.highScore) {
                     this.highScore = this.score;
                     this.saveHighScore();
                 }
             }

             updateComboDisplay() {
                 // Update combo counter
                 if (this.comboElement) {
                     this.comboElement.textContent = this.combo;
                     this.comboElement.className = this.combo >= 3 ? 'combo-active' : '';
                 }
                 
                 // Update max combo
                 if (this.comboMaxElement) {
                     this.comboMaxElement.textContent = this.maxCombo;
                 }
                 
                 // Update combo timer
                 if (this.comboTimerElement && this.combo > 0) {
                     const currentTime = Date.now();
                     const timeSinceLastAnswer = currentTime - this.lastAnswerTime;
                     const timeLeft = Math.max(0, this.comboTimeLimit - timeSinceLastAnswer);
                     const secondsLeft = Math.ceil(timeLeft / 1000);
                     
                     this.comboTimerElement.textContent = secondsLeft;
                     this.comboTimerElement.style.color = secondsLeft <= 3 ? '#ff0000' : '#ffff00';
                 } else if (this.comboTimerElement) {
                     this.comboTimerElement.textContent = '10';
                     this.comboTimerElement.style.color = '#ffff00';
                 }
             }

             updateHighScoreDisplay() {
                 if (this.highScoreElement) {
                     this.highScoreElement.textContent = this.highScore;
                 }
             }

             loadHighScore() {
                 const saved = localStorage.getItem('formelFuryHighScore');
                 return saved ? parseInt(saved) : 0;
             }

             saveHighScore() {
                 localStorage.setItem('formelFuryHighScore', this.highScore.toString());
                 this.updateHighScoreDisplay();
             }

                         showFormulaHUD() {
                 // Enhanced display with formula type
                 const displayText = `${this.currentFormula.typeName}: ${this.currentFormula.text}`;
                 this.formulaDisplay.innerHTML = `
                     <div style="font-size: 14px; color: #00ff0080; margin-bottom: 5px;">
                         ${this.currentFormula.typeName}
                     </div>
                     <div style="font-size: 24px;">
                         ${this.currentFormula.text}
                     </div>
                     <div style="font-size: 12px; color: #ffff0080; margin-top: 5px;">
                         Schwierigkeit: ${'‚≠ê'.repeat(Math.floor(this.currentFormula.difficulty))}
                     </div>
                 `;
                 this.formulaHUD.style.display = 'block';
                 this.formulaInput.focus();
             }

            hideFormulaHUD() {
                this.formulaHUD.style.display = 'none';
            }

            toggleFormulaHUD() {
                if (this.formulaHUD.style.display === 'none' || !this.formulaHUD.style.display) {
                    this.showFormulaHUD();
                } else {
                    this.hideFormulaHUD();
                }
            }

                         getDebugInfo() {
                 return {
                     currentFormula: this.currentFormula ? this.currentFormula.text : 'None',
                     score: this.score,
                     highScore: this.highScore,
                     combo: this.combo,
                     maxCombo: this.maxCombo,
                     correct: this.correctAnswers,
                     incorrect: this.incorrectAnswers
                 };
             }
        }

                 class Enemy {
             constructor(x, y, formulaSystem, type = 'basic') {
                 this.x = x;
                 this.y = y;
                 this.type = type;
                 
                 // Set type-specific properties
                 this.setTypeProperties();
                 
                 // AI behavior
                 this.targetX = x;
                 this.targetY = y;
                 this.velocity = { x: 0, y: 0 };
                 this.lastDirectionUpdate = 0;
                 this.directionUpdateInterval = this.baseDirectionInterval; // Use type-specific interval
                 
                 // Formula assignment based on type
                 this.assignedFormula = this.generateTypeSpecificFormula(formulaSystem);
                 this.isTargeted = false; // When player is close enough to see formula
                 this.showTargetIndicator = false; // Show targeting reticle
                 
                 // Status effects
                 this.isDead = false;
                 this.deathTimer = 0;
                 this.deathDuration = 1000; // 1 second death animation
                 
                 // Type-specific visual effects
                 this.pulsePhase = Math.random() * Math.PI * 2;
                 this.rotationSpeed = this.baseRotationSpeed;
             }

             setTypeProperties() {
                 const types = {
                     'polynom_zombie': {
                         name: 'Polynom-Zombie',
                         width: 35,
                         height: 35,
                         speed: 60,
                         maxSpeed: 90,
                         health: 80,
                         acceleration: 300,
                         color: '#00ff00',
                         glowColor: '#00ff0080',
                         shape: 'hexagon',
                         directionInterval: 150,
                         rotationSpeed: 0.02,
                         scoreMultiplier: 1.0,
                         difficultyBias: -0.5 // Prefers easier formulas
                     },
                     'gleichungs_geist': {
                         name: 'Gleichungs-Geist',
                         width: 25,
                         height: 25,
                         speed: 120,
                         maxSpeed: 180,
                         health: 60,
                         acceleration: 600,
                         color: '#00ffff',
                         glowColor: '#00ffff80',
                         shape: 'diamond',
                         directionInterval: 80,
                         rotationSpeed: 0.05,
                         scoreMultiplier: 1.3,
                         difficultyBias: 0 // Normal difficulty
                     },
                     'elite_mob': {
                         name: 'Elite-Algebra-Bestie',
                         width: 45,
                         height: 45,
                         speed: 40,
                         maxSpeed: 70,
                         health: 150,
                         acceleration: 200,
                         color: '#ff0080',
                         glowColor: '#ff008080',
                         shape: 'star',
                         directionInterval: 200,
                         rotationSpeed: 0.01,
                         scoreMultiplier: 2.0,
                         difficultyBias: 1.0 // Prefers harder formulas
                     },
                     'basic': {
                         name: 'Standard-Gegner',
                         width: 30,
                         height: 30,
                         speed: 80,
                         maxSpeed: 120,
                         health: 100,
                         acceleration: 400,
                         color: '#ff3300',
                         glowColor: '#ff330080',
                         shape: 'hexagon',
                         directionInterval: 100,
                         rotationSpeed: 0.03,
                         scoreMultiplier: 1.0,
                         difficultyBias: 0
                     }
                 };

                 const props = types[this.type] || types['basic'];
                 
                 // Apply properties
                 this.typeName = props.name;
                 this.width = props.width;
                 this.height = props.height;
                 this.speed = props.speed;
                 this.maxSpeed = props.maxSpeed;
                 this.health = props.health;
                 this.maxHealth = props.health;
                 this.acceleration = props.acceleration;
                 this.color = props.color;
                 this.glowColor = props.glowColor;
                 this.shape = props.shape;
                 this.baseDirectionInterval = props.directionInterval;
                 this.baseRotationSpeed = props.rotationSpeed;
                 this.scoreMultiplier = props.scoreMultiplier;
                 this.difficultyBias = props.difficultyBias;
                 this.angle = 0;
             }

             generateTypeSpecificFormula(formulaSystem) {
                 // Get available formula types for current progress
                 const availableTypes = formulaSystem.getAvailableFormulaTypes(['expansion_plus', 'expansion_minus', 'difference_squares', 'factorization_difference', 'factorization_square']);
                 
                 // Filter types based on enemy type preferences
                 let preferredTypes = [...availableTypes];
                 
                 switch (this.type) {
                     case 'polynom_zombie':
                         // Prefers basic expansion formulas
                         preferredTypes = availableTypes.filter(type => 
                             type === 'expansion_plus' || type === 'expansion_minus'
                         );
                         if (preferredTypes.length === 0) preferredTypes = [availableTypes[0]];
                         break;
                         
                     case 'gleichungs_geist':
                         // Prefers medium complexity
                         preferredTypes = availableTypes.filter(type => 
                             type === 'expansion_minus' || type === 'difference_squares'
                         );
                         if (preferredTypes.length === 0) preferredTypes = availableTypes;
                         break;
                         
                     case 'elite_mob':
                         // Prefers advanced formulas
                         preferredTypes = availableTypes.filter(type => 
                             type === 'factorization_difference' || type === 'factorization_square'
                         );
                         if (preferredTypes.length === 0) preferredTypes = availableTypes;
                         break;
                         
                     default:
                         // Standard distribution
                         break;
                 }
                 
                 // Select random type from preferred
                 const selectedType = preferredTypes[Math.floor(Math.random() * preferredTypes.length)];
                 
                 // Generate formula with type-specific difficulty bias
                 const originalGenerateCoefficient = formulaSystem.generateCoefficient.bind(formulaSystem);
                 const originalGenerateConstant = formulaSystem.generateConstant.bind(formulaSystem);
                 
                 // Temporarily modify generation for this enemy
                 formulaSystem.generateCoefficient = () => {
                     let coeff = originalGenerateCoefficient();
                     if (this.difficultyBias < 0) {
                         coeff = Math.max(1, coeff - 1); // Easier
                     } else if (this.difficultyBias > 0) {
                         coeff = Math.min(7, coeff + Math.floor(this.difficultyBias * 2)); // Harder
                     }
                     return coeff;
                 };
                 
                 formulaSystem.generateConstant = () => {
                     let constant = originalGenerateConstant();
                     if (this.difficultyBias < 0) {
                         constant = Math.max(1, constant - 1); // Easier
                     } else if (this.difficultyBias > 0) {
                         constant = Math.min(10, constant + Math.floor(this.difficultyBias * 2)); // Harder
                     }
                     return constant;
                 };
                 
                 // Generate formula
                 const formula = formulaSystem.generateFormulaByType(selectedType);
                 
                 // Restore original methods
                 formulaSystem.generateCoefficient = originalGenerateCoefficient;
                 formulaSystem.generateConstant = originalGenerateConstant;
                 
                 // Adjust difficulty for this enemy type
                 formula.difficulty = Math.max(1, Math.min(5, formula.difficulty + this.difficultyBias));
                 
                 return formula;
             }

            update(deltaTime, playerX, playerY, canvasWidth, canvasHeight) {
                if (this.isDead) {
                    this.updateDeathAnimation(deltaTime);
                    return;
                }
                
                const dt = deltaTime / 1000;
                
                // Update AI behavior
                this.updateAI(playerX, playerY, deltaTime);
                
                // Update movement
                this.updateMovement(dt);
                
                // Keep within canvas bounds
                this.handleBoundaryCollision(canvasWidth, canvasHeight);
                
                // Update visual effects
                this.pulsePhase += deltaTime * 0.003; // Slow pulsing
                
                // Check if player is close enough to see formula
                const distanceToPlayer = Math.sqrt((this.x - playerX) ** 2 + (this.y - playerY) ** 2);
                this.isTargeted = distanceToPlayer < 100; // Show formula when player is within 100px
            }

            updateAI(playerX, playerY, deltaTime) {
                // Simple AI: Move towards player with some randomness
                const currentTime = Date.now();
                
                if (currentTime - this.lastDirectionUpdate > this.directionUpdateInterval) {
                    // Calculate direction to player with some noise
                    const dx = playerX - this.x;
                    const dy = playerY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        // Add some randomness to movement
                        const noise = 0.3;
                        const randomAngle = (Math.random() - 0.5) * noise;
                        const angle = Math.atan2(dy, dx) + randomAngle;
                        
                        this.targetX = this.x + Math.cos(angle) * this.speed;
                        this.targetY = this.y + Math.sin(angle) * this.speed;
                    }
                    
                    this.lastDirectionUpdate = currentTime;
                }
            }

            updateMovement(dt) {
                // Calculate desired velocity towards target
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                let targetVelX = 0;
                let targetVelY = 0;
                
                if (distance > 5) { // Dead zone to prevent jittering
                    targetVelX = (dx / distance) * this.speed;
                    targetVelY = (dy / distance) * this.speed;
                }
                
                // Apply acceleration towards target velocity
                const velDiffX = targetVelX - this.velocity.x;
                const velDiffY = targetVelY - this.velocity.y;
                
                this.velocity.x += velDiffX * this.acceleration * dt;
                this.velocity.y += velDiffY * this.acceleration * dt;
                
                // Limit max speed
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.velocity.x * dt;
                this.y += this.velocity.y * dt;
                
                // Update angle for rotation
                if (Math.abs(this.velocity.x) > 1 || Math.abs(this.velocity.y) > 1) {
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
            }

            updateDeathAnimation(deltaTime) {
                this.deathTimer += deltaTime;
                if (this.deathTimer >= this.deathDuration) {
                    this.isDead = true; // Mark for removal
                }
            }

            handleBoundaryCollision(canvasWidth, canvasHeight) {
                // Bounce off walls
                if (this.x < this.width / 2) {
                    this.x = this.width / 2;
                    this.velocity.x = Math.abs(this.velocity.x) * 0.5;
                }
                if (this.x > canvasWidth - this.width / 2) {
                    this.x = canvasWidth - this.width / 2;
                    this.velocity.x = -Math.abs(this.velocity.x) * 0.5;
                }
                if (this.y < this.height / 2) {
                    this.y = this.height / 2;
                    this.velocity.y = Math.abs(this.velocity.y) * 0.5;
                }
                if (this.y > canvasHeight - this.height / 2) {
                    this.y = canvasHeight - this.height / 2;
                    this.velocity.y = -Math.abs(this.velocity.y) * 0.5;
                }
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.health = 0;
                    this.startDeathAnimation();
                }
            }

            startDeathAnimation() {
                this.isDead = true;
                this.deathTimer = 0;
            }

            isCollidingWith(other) {
                const dx = this.x - other.x;
                const dy = this.y - other.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                return distance < (this.width + other.width) / 2;
            }

                         render(ctx) {
                 if (this.isDead && this.deathTimer >= this.deathDuration) {
                     return; // Don't render if fully dead
                 }
                 
                 ctx.save();
                 
                 // Death animation effect
                 if (this.isDead) {
                     const deathProgress = this.deathTimer / this.deathDuration;
                     ctx.globalAlpha = 1 - deathProgress;
                     ctx.scale(1 + deathProgress * 0.5, 1 + deathProgress * 0.5);
                 }
                 
                 // Type-specific pulsing glow effect
                 const pulseIntensity = 0.3 + 0.2 * Math.sin(this.pulsePhase);
                 ctx.shadowColor = this.glowColor;
                 ctx.shadowBlur = 15 * pulseIntensity;
                 
                 // Translate to enemy position
                 ctx.translate(this.x, this.y);
                 
                 // Rotate based on movement direction and type-specific speed
                 ctx.rotate(this.angle);
                 
                 // Draw enemy body based on shape type
                 ctx.fillStyle = this.color;
                 this.renderShape(ctx);
                 
                 // Draw type-specific inner core
                 this.renderCore(ctx);
                 
                 // Draw health bar
                 ctx.restore();
                 this.renderHealthBar(ctx);
                 
                 // Draw type indicator
                 this.renderTypeIndicator(ctx);
                 
                 // Draw targeting indicator
                 if (this.showTargetIndicator && !this.isDead) {
                     this.renderTargetIndicator(ctx);
                 }
                 
                 // Draw formula if player is nearby
                 if (this.isTargeted && !this.isDead) {
                     this.renderFormula(ctx);
                 }
             }

             renderShape(ctx) {
                 ctx.beginPath();
                 
                 switch (this.shape) {
                     case 'hexagon':
                         for (let i = 0; i < 6; i++) {
                             const angle = (i * Math.PI) / 3;
                             const x = Math.cos(angle) * this.width / 2;
                             const y = Math.sin(angle) * this.height / 2;
                             if (i === 0) {
                                 ctx.moveTo(x, y);
                             } else {
                                 ctx.lineTo(x, y);
                             }
                         }
                         break;
                         
                     case 'diamond':
                         const halfW = this.width / 2;
                         const halfH = this.height / 2;
                         ctx.moveTo(halfW, 0);
                         ctx.lineTo(0, halfH);
                         ctx.lineTo(-halfW, 0);
                         ctx.lineTo(0, -halfH);
                         break;
                         
                     case 'star':
                         const outerRadius = this.width / 2;
                         const innerRadius = outerRadius * 0.5;
                         for (let i = 0; i < 10; i++) {
                             const angle = (i * Math.PI) / 5;
                             const radius = i % 2 === 0 ? outerRadius : innerRadius;
                             const x = Math.cos(angle) * radius;
                             const y = Math.sin(angle) * radius;
                             if (i === 0) {
                                 ctx.moveTo(x, y);
                             } else {
                                 ctx.lineTo(x, y);
                             }
                         }
                         break;
                         
                     default: // hexagon as fallback
                         for (let i = 0; i < 6; i++) {
                             const angle = (i * Math.PI) / 3;
                             const x = Math.cos(angle) * this.width / 2;
                             const y = Math.sin(angle) * this.height / 2;
                             if (i === 0) {
                                 ctx.moveTo(x, y);
                             } else {
                                 ctx.lineTo(x, y);
                             }
                         }
                 }
                 
                 ctx.closePath();
                 ctx.fill();
             }

             renderCore(ctx) {
                 ctx.fillStyle = '#ffffff';
                 
                 switch (this.type) {
                     case 'polynom_zombie':
                         // Simple dot
                         ctx.beginPath();
                         ctx.arc(0, 0, 3, 0, Math.PI * 2);
                         ctx.fill();
                         break;
                         
                     case 'gleichungs_geist':
                         // Cross pattern
                         ctx.fillRect(-1, -6, 2, 12);
                         ctx.fillRect(-6, -1, 12, 2);
                         break;
                         
                     case 'elite_mob':
                         // Complex pattern
                         ctx.beginPath();
                         ctx.arc(0, 0, 4, 0, Math.PI * 2);
                         ctx.fill();
                         ctx.fillRect(-1, -8, 2, 16);
                         ctx.fillRect(-8, -1, 16, 2);
                         break;
                         
                     default:
                         ctx.beginPath();
                         ctx.arc(0, 0, 4, 0, Math.PI * 2);
                         ctx.fill();
                 }
             }

             renderTypeIndicator(ctx) {
                 if (this.type === 'basic') return;
                 
                 // Small type indicator above enemy
                 ctx.save();
                 ctx.fillStyle = this.color;
                 ctx.font = '10px Courier New';
                 ctx.textAlign = 'center';
                 
                 let indicator = '';
                 switch (this.type) {
                     case 'polynom_zombie':
                         indicator = 'PZ';
                         break;
                     case 'gleichungs_geist':
                         indicator = 'GG';
                         break;
                     case 'elite_mob':
                         indicator = 'EB';
                         break;
                 }
                 
                 const textY = this.y - this.height / 2 - 45;
                 ctx.fillText(indicator, this.x, textY);
                 ctx.restore();
             }

            renderHealthBar(ctx) {
                if (this.health >= this.maxHealth) return; // Don't show full health
                
                const barWidth = this.width + 10;
                const barHeight = 4;
                const barX = this.x - barWidth / 2;
                const barY = this.y - this.height / 2 - 10;
                
                // Background
                ctx.fillStyle = '#333';
                ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Health
                const healthPercent = this.health / this.maxHealth;
                const healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                ctx.fillStyle = healthColor;
                ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
            }

            renderFormula(ctx) {
                if (!this.assignedFormula) return;
                
                ctx.save();
                
                // Formula background
                const text = this.assignedFormula.text;
                ctx.font = '16px Courier New';
                const textMetrics = ctx.measureText(text);
                const textWidth = textMetrics.width;
                const textHeight = 20;
                
                const bgX = this.x - textWidth / 2 - 5;
                const bgY = this.y - this.height / 2 - 35;
                
                // Background with glow
                ctx.shadowColor = '#ff330080';
                ctx.shadowBlur = 10;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(bgX, bgY, textWidth + 10, textHeight + 5);
                
                // Border
                ctx.strokeStyle = '#ff3300';
                ctx.lineWidth = 1;
                ctx.strokeRect(bgX, bgY, textWidth + 10, textHeight + 5);
                
                // Text
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ff3300';
                ctx.textAlign = 'center';
                ctx.fillText(text, this.x, this.y - this.height / 2 - 20);
                
                ctx.restore();
            }

            renderTargetIndicator(ctx) {
                ctx.save();
                
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2;
                ctx.shadowColor = '#ffff0080';
                ctx.shadowBlur = 5;
                
                // Draw targeting crosshairs
                const size = this.width / 2 + 15;
                
                // Outer circle
                ctx.beginPath();
                ctx.arc(this.x, this.y, size, 0, Math.PI * 2);
                ctx.stroke();
                
                // Cross lines
                ctx.beginPath();
                ctx.moveTo(this.x - size - 5, this.y);
                ctx.lineTo(this.x - size + 5, this.y);
                ctx.moveTo(this.x + size - 5, this.y);
                ctx.lineTo(this.x + size + 5, this.y);
                ctx.moveTo(this.x, this.y - size - 5);
                ctx.lineTo(this.x, this.y - size + 5);
                ctx.moveTo(this.x, this.y + size - 5);
                ctx.lineTo(this.x, this.y + size + 5);
                ctx.stroke();
                
                // Target text
                ctx.fillStyle = '#ffff00';
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                ctx.fillText('KLICKEN ZUM ANGRIFF', this.x, this.y + size + 20);
                
                ctx.restore();
            }

            shouldBeRemoved() {
                return this.isDead && this.deathTimer >= this.deathDuration;
            }

                         getDebugInfo() {
                 return {
                     type: this.typeName,
                     position: `(${Math.round(this.x)}, ${Math.round(this.y)})`,
                     health: `${this.health}/${this.maxHealth}`,
                     formula: this.assignedFormula ? this.assignedFormula.text : 'None',
                     difficulty: this.assignedFormula ? this.assignedFormula.difficulty.toFixed(1) : 'N/A',
                     isTargeted: this.isTargeted
                 };
             }
        }

                 class EnemySpawner {
             constructor(formulaSystem) {
                 this.formulaSystem = formulaSystem;
                 this.enemies = [];
                 this.spawnTimer = 0;
                 this.spawnInterval = 3000; // Spawn every 3 seconds
                 this.maxEnemies = 6; // Increased for variety
                 this.spawnDistance = 100; // Minimum distance from player to spawn
                 
                 // Spawn probability configuration
                 this.spawnProbabilities = {
                     polynom_zombie: 0.5,    // 50% base chance
                     gleichungs_geist: 0.3,  // 30% base chance
                     elite_mob: 0.1,         // 10% base chance
                     basic: 0.1              // 10% fallback
                 };
             }

             getSpawnType(playerScore, combo) {
                 // Adjust probabilities based on player progress
                 let probabilities = { ...this.spawnProbabilities };
                 
                 // Early game (score < 500): More zombies, fewer advanced
                 if (playerScore < 500) {
                     probabilities.polynom_zombie = 0.7;
                     probabilities.gleichungs_geist = 0.2;
                     probabilities.elite_mob = 0.05;
                     probabilities.basic = 0.05;
                 }
                 // Mid game (500-1500): Balanced
                 else if (playerScore < 1500) {
                     probabilities.polynom_zombie = 0.4;
                     probabilities.gleichungs_geist = 0.4;
                     probabilities.elite_mob = 0.15;
                     probabilities.basic = 0.05;
                 }
                 // Late game (1500+): More advanced enemies
                 else {
                     probabilities.polynom_zombie = 0.2;
                     probabilities.gleichungs_geist = 0.4;
                     probabilities.elite_mob = 0.35;
                     probabilities.basic = 0.05;
                 }
                 
                 // High combo = more elite enemies
                 if (combo >= 5) {
                     probabilities.elite_mob += 0.1;
                     probabilities.polynom_zombie -= 0.05;
                     probabilities.gleichungs_geist -= 0.05;
                 }
                 
                 if (combo >= 10) {
                     probabilities.elite_mob += 0.15;
                     probabilities.polynom_zombie -= 0.1;
                     probabilities.gleichungs_geist -= 0.05;
                 }
                 
                 // Select type based on probabilities
                 const rand = Math.random();
                 let cumulative = 0;
                 
                 for (const [type, prob] of Object.entries(probabilities)) {
                     cumulative += prob;
                     if (rand <= cumulative) {
                         return type;
                     }
                 }
                 
                 return 'basic'; // Fallback
             }

                         update(deltaTime, playerX, playerY, canvasWidth, canvasHeight, playerScore = 0, combo = 0) {
                 this.spawnTimer += deltaTime;
                 
                 // Dynamic spawn interval based on progress
                 let currentSpawnInterval = this.spawnInterval;
                 if (playerScore > 1000) currentSpawnInterval = 2500; // Faster spawning
                 if (playerScore > 2000) currentSpawnInterval = 2000; // Even faster
                 
                 // Spawn new enemies
                 if (this.spawnTimer >= currentSpawnInterval && this.enemies.length < this.maxEnemies) {
                     this.spawnEnemy(playerX, playerY, canvasWidth, canvasHeight, playerScore, combo);
                     this.spawnTimer = 0;
                 }
                 
                 // Update all enemies
                 for (let i = this.enemies.length - 1; i >= 0; i--) {
                     const enemy = this.enemies[i];
                     enemy.update(deltaTime, playerX, playerY, canvasWidth, canvasHeight);
                     
                     // Remove dead enemies
                     if (enemy.shouldBeRemoved()) {
                         this.enemies.splice(i, 1);
                     }
                 }
             }

                         spawnEnemy(playerX, playerY, canvasWidth, canvasHeight, playerScore = 0, combo = 0) {
                 let spawnX, spawnY;
                 let attempts = 0;
                 
                 // Try to find a spawn position away from player
                 do {
                     spawnX = Math.random() * (canvasWidth - 100) + 50;
                     spawnY = Math.random() * (canvasHeight - 100) + 50;
                     const distance = Math.sqrt((spawnX - playerX) ** 2 + (spawnY - playerY) ** 2);
                     
                     if (distance >= this.spawnDistance) {
                         break;
                     }
                     attempts++;
                 } while (attempts < 20);
                 
                 // Determine enemy type based on game progress
                 const enemyType = this.getSpawnType(playerScore, combo);
                 
                 // Create new enemy with specific type
                 const enemy = new Enemy(spawnX, spawnY, this.formulaSystem, enemyType);
                 this.enemies.push(enemy);
                 
                 console.log(`${enemy.typeName} spawned at (${Math.round(spawnX)}, ${Math.round(spawnY)}) with ${enemy.assignedFormula.typeName}: ${enemy.assignedFormula.text} (Difficulty: ${enemy.assignedFormula.difficulty.toFixed(1)})`);
             }

            checkCollisions(player) {
                for (const enemy of this.enemies) {
                    if (!enemy.isDead && enemy.isCollidingWith(player)) {
                        return enemy;
                    }
                }
                return null;
            }

            render(ctx) {
                for (const enemy of this.enemies) {
                    enemy.render(ctx);
                }
            }

                         getDebugInfo() {
                 const typeCounts = {};
                 this.enemies.forEach(enemy => {
                     typeCounts[enemy.type] = (typeCounts[enemy.type] || 0) + 1;
                 });
                 
                 return {
                     enemyCount: this.enemies.length,
                     types: typeCounts,
                     nextSpawn: Math.round((this.spawnInterval - this.spawnTimer) / 1000),
                     enemies: this.enemies.map(e => e.getDebugInfo())
                 };
             }
        }

        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.speed = 200; // pixels per second
                this.maxSpeed = 300;
                
                // Movement state
                this.velocity = { x: 0, y: 0 };
                this.acceleration = 800; // pixels per second squared
                this.friction = 0.85;
                
                // Visual properties
                this.color = '#00ff00';
                this.glowColor = '#00ff0080';
                this.angle = 0; // for rotation effect
            }

            update(deltaTime, inputHandler, canvasWidth, canvasHeight) {
                // Convert deltaTime from milliseconds to seconds
                const dt = deltaTime / 1000;
                
                // Handle input and apply acceleration
                let targetVelX = 0;
                let targetVelY = 0;
                
                if (inputHandler.isPressed('w') || inputHandler.isPressed('W')) {
                    targetVelY = -this.speed;
                }
                if (inputHandler.isPressed('s') || inputHandler.isPressed('S')) {
                    targetVelY = this.speed;
                }
                if (inputHandler.isPressed('a') || inputHandler.isPressed('A')) {
                    targetVelX = -this.speed;
                }
                if (inputHandler.isPressed('d') || inputHandler.isPressed('D')) {
                    targetVelX = this.speed;
                }
                
                // Diagonal movement compensation
                if (targetVelX !== 0 && targetVelY !== 0) {
                    targetVelX *= 0.707; // sqrt(2)/2 for diagonal movement
                    targetVelY *= 0.707;
                }
                
                // Apply acceleration towards target velocity
                const velDiffX = targetVelX - this.velocity.x;
                const velDiffY = targetVelY - this.velocity.y;
                
                this.velocity.x += velDiffX * this.acceleration * dt;
                this.velocity.y += velDiffY * this.acceleration * dt;
                
                // Apply friction when no input
                if (targetVelX === 0 && targetVelY === 0) {
                    this.velocity.x *= this.friction;
                    this.velocity.y *= this.friction;
                }
                
                // Limit max speed
                const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
                if (speed > this.maxSpeed) {
                    this.velocity.x = (this.velocity.x / speed) * this.maxSpeed;
                    this.velocity.y = (this.velocity.y / speed) * this.maxSpeed;
                }
                
                // Update position
                this.x += this.velocity.x * dt;
                this.y += this.velocity.y * dt;
                
                // Collision detection with canvas boundaries
                this.handleBoundaryCollision(canvasWidth, canvasHeight);
                
                // Update visual angle for rotation effect
                if (Math.abs(this.velocity.x) > 1 || Math.abs(this.velocity.y) > 1) {
                    this.angle = Math.atan2(this.velocity.y, this.velocity.x);
                }
            }

            handleBoundaryCollision(canvasWidth, canvasHeight) {
                // Left boundary
                if (this.x < this.width / 2) {
                    this.x = this.width / 2;
                    this.velocity.x = 0;
                }
                // Right boundary
                if (this.x > canvasWidth - this.width / 2) {
                    this.x = canvasWidth - this.width / 2;
                    this.velocity.x = 0;
                }
                // Top boundary
                if (this.y < this.height / 2) {
                    this.y = this.height / 2;
                    this.velocity.y = 0;
                }
                // Bottom boundary
                if (this.y > canvasHeight - this.height / 2) {
                    this.y = canvasHeight - this.height / 2;
                    this.velocity.y = 0;
                }
            }

            render(ctx) {
                ctx.save();
                
                // Draw glow effect
                ctx.shadowColor = this.glowColor;
                ctx.shadowBlur = 15;
                
                // Translate to player position
                ctx.translate(this.x, this.y);
                
                // Rotate based on movement direction
                ctx.rotate(this.angle);
                
                // Draw player body (diamond shape for sci-fi look)
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.moveTo(this.width / 2, 0);
                ctx.lineTo(0, this.height / 2);
                ctx.lineTo(-this.width / 2, 0);
                ctx.lineTo(0, -this.height / 2);
                ctx.closePath();
                ctx.fill();
                
                // Draw center core
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(0, 0, 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw direction indicator
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(this.width / 2 + 5, 0);
                ctx.stroke();
                
                ctx.restore();
            }

            getDebugInfo() {
                return {
                    position: `(${Math.round(this.x)}, ${Math.round(this.y)})`,
                    velocity: `(${Math.round(this.velocity.x)}, ${Math.round(this.velocity.y)})`,
                    speed: Math.round(Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2))
                };
            }
        }

        class InputHandler {
            constructor(canvas) {
                this.canvas = canvas;
                this.keys = {};
                this.mouse = {
                    x: 0,
                    y: 0,
                    clicked: false,
                    justClicked: false
                };
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                });
                
                // Mouse events
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click
                        this.mouse.clicked = true;
                        this.mouse.justClicked = true;
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (e.button === 0) { // Left click
                        this.mouse.clicked = false;
                    }
                });

                // Prevent context menu on right click
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
                
                // Prevent default behavior for WASD keys
                document.addEventListener('keydown', (e) => {
                    if (['w', 'a', 's', 'd', 'W', 'A', 'S', 'D'].includes(e.key)) {
                        e.preventDefault();
                    }
                    
                    // Handle SPACE key for formula system
                    if (e.key === ' ' || e.key === 'Space') {
                        e.preventDefault();
                        // This will be handled by GameEngine
                    }
                });
            }

            isPressed(key) {
                return !!this.keys[key];
            }

            isSpacePressed() {
                return this.keys[' '] || this.keys['Space'];
            }

            getMousePosition() {
                return { x: this.mouse.x, y: this.mouse.y };
            }

            isMouseClicked() {
                return this.mouse.clicked;
            }

            wasMouseJustClicked() {
                const wasClicked = this.mouse.justClicked;
                this.mouse.justClicked = false; // Reset for next frame
                return wasClicked;
            }

            getDebugInfo() {
                const pressedKeys = Object.keys(this.keys).filter(key => this.keys[key]);
                return `Keys: ${pressedKeys.join(', ') || 'None'}, Mouse: (${Math.round(this.mouse.x)}, ${Math.round(this.mouse.y)})`;
            }
        }

        class GameEngine {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.fpsCounter = document.getElementById('fpsCounter');
                
                // FPS-Tracking
                this.lastTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                this.fpsUpdateInterval = 1000; // Update FPS every second
                this.lastFpsUpdate = 0;
                
                // Game state
                this.isRunning = false;
                
                // Game objects
                this.player = null;
                this.inputHandler = null;
                this.formulaSystem = null;
                this.enemySpawner = null;
                
                // Input state tracking
                this.spacePressed = false;
                
                // Game state
                this.playerHealth = 100;
                this.playerMaxHealth = 100;
                this.isGameOver = false;
                this.isPaused = false;
                
                                 // Combat system
                 this.targetedEnemy = null;
                 this.combatMode = false;
                 this.lastDamageTime = 0;
                 this.damageImmuneTime = 1000; // 1 second immunity after taking damage
                 this.combatStartTime = 0;
                
                // Pause menu elements
                this.pauseMenu = null;
                this.pauseStats = {
                    score: null,
                    correct: null,
                    incorrect: null,
                    accuracy: null,
                    health: null
                };
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.initializeGameObjects();
                this.start();
            }

            initializeGameObjects() {
                // Create input handler (pass canvas for mouse events)
                this.inputHandler = new InputHandler(this.canvas);
                
                // Create player at center of canvas
                this.player = new Player(
                    this.canvas.width / 2,
                    this.canvas.height / 2
                );
                
                // Create formula system with combat integration
                this.formulaSystem = new FormulaSystem();
                this.integrateFormulaSystemWithCombat();
                
                // Create enemy spawner
                this.enemySpawner = new EnemySpawner(this.formulaSystem);
                
                // Initialize pause menu
                this.initializePauseMenu();
            }

            initializePauseMenu() {
                this.pauseMenu = document.getElementById('pauseMenu');
                this.pauseStats.score = document.getElementById('pauseScore');
                this.pauseStats.correct = document.getElementById('pauseCorrect');
                this.pauseStats.incorrect = document.getElementById('pauseIncorrect');
                this.pauseStats.accuracy = document.getElementById('pauseAccuracy');
                this.pauseStats.health = document.getElementById('pauseHealth');
            }

            integrateFormulaSystemWithCombat() {
                // Override formula system methods to integrate with combat
                const originalSubmitAnswer = this.formulaSystem.submitAnswer.bind(this.formulaSystem);
                const originalSkipFormula = this.formulaSystem.skipFormula.bind(this.formulaSystem);
                
                this.formulaSystem.submitAnswer = () => {
                    const userAnswer = this.formulaSystem.formulaInput.value.trim();
                    
                    if (!userAnswer) {
                        this.formulaSystem.showFeedback('Bitte gib eine Antwort ein!', false);
                        return;
                    }
                    
                    const isCorrect = this.formulaSystem.validateAnswer(userAnswer);
                    
                    if (isCorrect) {
                        this.handleCorrectAnswer();
                    } else {
                        this.handleWrongAnswer();
                    }
                    
                    this.formulaSystem.formulaInput.value = '';
                };
                
                this.formulaSystem.skipFormula = () => {
                    if (this.targetedEnemy) {
                        this.formulaSystem.showFeedback(`√úbersprungen! Du nimmst Schaden!`, false);
                        this.dealDamageToPlayer(15);
                    }
                    this.exitCombatMode();
                };
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                // Re-center player if it exists
                if (this.player) {
                    this.player.x = this.canvas.width / 2;
                    this.player.y = this.canvas.height / 2;
                }
            }

            setupEventListeners() {
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });

                // Escape key for pause
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.togglePauseMenu();
                    }
                });

                // Focus canvas for keyboard input
                this.canvas.focus();
                this.canvas.setAttribute('tabindex', '0');
            }

            start() {
                this.isRunning = true;
                this.gameLoop();
            }

            stop() {
                this.isRunning = false;
            }

            gameLoop(currentTime = 0) {
                if (!this.isRunning) return;

                // Calculate delta time
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                // Update FPS
                this.updateFPS(currentTime);

                // Update game objects
                this.update(deltaTime);

                // Clear canvas
                this.clearCanvas();

                // Render background
                this.renderBackground();

                // Render game objects
                this.render();

                // Render debug info
                this.renderDebugInfo();

                // Continue game loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            updateFPS(currentTime) {
                this.frameCount++;
                
                if (currentTime - this.lastFpsUpdate >= this.fpsUpdateInterval) {
                    this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastFpsUpdate));
                    this.frameCount = 0;
                    this.lastFpsUpdate = currentTime;
                    
                    // Update FPS display
                    this.fpsCounter.textContent = `FPS: ${this.fps}`;
                }
            }

            update(deltaTime) {
                if (this.isGameOver) {
                    this.handleGameOver();
                    return;
                }
                
                                 // Skip updates if paused
                 if (this.isPaused) {
                     return;
                 }
                 
                 // Update combo timer
                 if (this.formulaSystem) {
                     this.formulaSystem.updateComboTimer();
                     this.formulaSystem.updateComboDisplay();
                 }
                 
                 // Update player
                if (this.player && this.inputHandler) {
                    this.player.update(deltaTime, this.inputHandler, this.canvas.width, this.canvas.height);
                }
                
                                 // Update enemies with player progress info
                 if (this.enemySpawner && this.player && this.formulaSystem) {
                     this.enemySpawner.update(
                         deltaTime, 
                         this.player.x, 
                         this.player.y, 
                         this.canvas.width, 
                         this.canvas.height,
                         this.formulaSystem.score,
                         this.formulaSystem.combo
                     );
                 }
                
                // Handle targeting system
                this.handleTargeting();
                
                // Check collisions (only if not in combat mode)
                if (!this.combatMode) {
                    this.handleCollisions();
                }
                
                // Handle SPACE key for formula system
                this.handleFormulaInput();
                
                // Clean up dead targeted enemy
                if (this.targetedEnemy && this.targetedEnemy.shouldBeRemoved()) {
                    this.exitCombatMode();
                }
            }

            handleTargeting() {
                if (!this.inputHandler || !this.enemySpawner || this.combatMode || this.isPaused) return;
                
                // Handle mouse clicks for targeting
                if (this.inputHandler.wasMouseJustClicked()) {
                    const mousePos = this.inputHandler.getMousePosition();
                    const clickedEnemy = this.getEnemyAtPosition(mousePos.x, mousePos.y);
                    
                    if (clickedEnemy && !clickedEnemy.isDead) {
                        this.targetEnemy(clickedEnemy);
                    }
                }
                
                // Visual targeting for nearby enemies (backup method)
                const nearbyEnemy = this.getNearestEnemyInRange(this.player.x, this.player.y, 80);
                if (nearbyEnemy && !this.targetedEnemy) {
                    // Show target indicator but don't auto-target
                    nearbyEnemy.showTargetIndicator = true;
                } else if (!nearbyEnemy) {
                    // Clear target indicators
                    this.enemySpawner.enemies.forEach(enemy => {
                        enemy.showTargetIndicator = false;
                    });
                }
            }

            getEnemyAtPosition(x, y) {
                for (const enemy of this.enemySpawner.enemies) {
                    if (enemy.isDead) continue;
                    
                    const dx = x - enemy.x;
                    const dy = y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= enemy.width / 2 + 10) { // Small click tolerance
                        return enemy;
                    }
                }
                return null;
            }

            getNearestEnemyInRange(x, y, range) {
                let nearest = null;
                let nearestDistance = range;
                
                for (const enemy of this.enemySpawner.enemies) {
                    if (enemy.isDead) continue;
                    
                    const dx = x - enemy.x;
                    const dy = y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < nearestDistance) {
                        nearest = enemy;
                        nearestDistance = distance;
                    }
                }
                
                return nearest;
            }

                         targetEnemy(enemy) {
                 this.targetedEnemy = enemy;
                 this.combatMode = true;
                 this.combatStartTime = Date.now();
                 
                 // Use the enemy's assigned formula
                 this.formulaSystem.currentFormula = enemy.assignedFormula;
                 this.formulaSystem.currentSolution = enemy.assignedFormula.solutions;
                 
                 // Show combat UI
                 this.formulaSystem.showFormulaHUD();
                 
                 console.log(`Targeted enemy with formula: ${enemy.assignedFormula.text} (Difficulty: ${enemy.assignedFormula.difficulty})`);
             }

            exitCombatMode() {
                this.targetedEnemy = null;
                this.combatMode = false;
                this.formulaSystem.hideFormulaHUD();
                
                // Clear target indicators
                this.enemySpawner.enemies.forEach(enemy => {
                    enemy.showTargetIndicator = false;
                });
            }

                         handleCorrectAnswer() {
                 const currentTime = Date.now();
                 const timeTaken = this.combatMode ? currentTime - this.combatStartTime : 5000;
                 
                 if (this.targetedEnemy) {
                     // Calculate base score
                     let earnedScore = this.formulaSystem.calculateScore(
                         this.targetedEnemy.assignedFormula, 
                         timeTaken, 
                         true
                     );
                     
                     // Apply enemy type multiplier
                     earnedScore = Math.round(earnedScore * this.targetedEnemy.scoreMultiplier);
                     
                     // Update stats
                     this.formulaSystem.correctAnswers++;
                     this.formulaSystem.score += earnedScore;
                     this.formulaSystem.incrementCombo();
                     
                     // Kill the enemy
                     this.targetedEnemy.startDeathAnimation();
                     
                     // Show detailed feedback with enemy type
                     const speedText = timeTaken < 5000 ? ' (Schnell!)' : '';
                     const comboText = this.formulaSystem.combo >= 3 ? ` Combo x${this.formulaSystem.combo}!` : '';
                     const typeText = this.targetedEnemy.scoreMultiplier > 1 ? ` [${this.targetedEnemy.typeName}]` : '';
                     this.formulaSystem.showFeedback(`Treffer! +${earnedScore} Punkte${typeText}${speedText}${comboText}`, true);
                     
                     console.log(`${this.targetedEnemy.typeName} eliminated! Score: ${earnedScore} (Base: ${Math.round(earnedScore/this.targetedEnemy.scoreMultiplier)}, Multiplier: ${this.targetedEnemy.scoreMultiplier}x, Difficulty: ${this.targetedEnemy.assignedFormula.difficulty.toFixed(1)}, Time: ${timeTaken}ms, Combo: ${this.formulaSystem.combo})`);
                 } else {
                     // Regular formula practice
                     const earnedScore = this.formulaSystem.calculateScore(
                         this.formulaSystem.currentFormula, 
                         timeTaken, 
                         false
                     );
                     
                     this.formulaSystem.correctAnswers++;
                     this.formulaSystem.score += earnedScore;
                     this.formulaSystem.incrementCombo();
                     this.formulaSystem.showFeedback(`Richtig! +${earnedScore} Punkte`, true);
                 }
                 
                 this.formulaSystem.updateScoreDisplay();
                 this.exitCombatMode();
                 
                 // Generate new formula after delay
                 setTimeout(() => {
                     this.formulaSystem.generateFormula();
                 }, 1500);
             }

                         handleWrongAnswer() {
                 // Break combo on wrong answer
                 this.formulaSystem.breakCombo('Falsche Antwort!');
                 
                 if (this.targetedEnemy) {
                     // Player takes damage in combat
                     this.formulaSystem.incorrectAnswers++;
                     this.formulaSystem.score = Math.max(0, this.formulaSystem.score - 50);
                     this.dealDamageToPlayer(20);
                     this.formulaSystem.showFeedback(`Falsch! Du nimmst Schaden! Richtig: ${this.formulaSystem.currentSolution[0]}`, false);
                 } else {
                     // Regular formula practice
                     this.formulaSystem.incorrectAnswers++;
                     this.formulaSystem.score = Math.max(0, this.formulaSystem.score - 25);
                     this.formulaSystem.showFeedback(`Falsch! Richtig w√§re: ${this.formulaSystem.currentSolution[0]}`, false);
                 }
                 
                 this.formulaSystem.updateScoreDisplay();
                 this.exitCombatMode();
                 
                 // Generate new formula after delay
                 setTimeout(() => {
                     this.formulaSystem.generateFormula();
                 }, 2000);
             }

            dealDamageToPlayer(damage) {
                const currentTime = Date.now();
                if (currentTime - this.lastDamageTime < this.damageImmuneTime) {
                    return; // Player is immune
                }
                
                this.playerHealth -= damage;
                this.playerHealth = Math.max(0, this.playerHealth);
                this.lastDamageTime = currentTime;
                
                console.log(`Player took ${damage} damage. Health: ${this.playerHealth}/${this.playerMaxHealth}`);
                
                if (this.playerHealth <= 0) {
                    this.triggerGameOver();
                }
            }

            triggerGameOver() {
                this.isGameOver = true;
                this.exitCombatMode();
                console.log('Game Over! Player died.');
            }

            handleGameOver() {
                // Simple respawn for now
                setTimeout(() => {
                    this.restartGame();
                }, 3000);
            }

            restartGame() {
                this.isGameOver = false;
                this.isPaused = false;
                this.playerHealth = this.playerMaxHealth;
                this.exitCombatMode();
                
                // Reset player position
                this.player.x = this.canvas.width / 2;
                this.player.y = this.canvas.height / 2;
                
                // Clear enemies
                this.enemySpawner.enemies = [];
                
                                 // Reset formula system
                 this.formulaSystem.score = 0;
                 this.formulaSystem.correctAnswers = 0;
                 this.formulaSystem.incorrectAnswers = 0;
                 this.formulaSystem.combo = 0;
                 this.formulaSystem.maxCombo = 0;
                 this.formulaSystem.startComboTimer();
                 this.formulaSystem.updateScoreDisplay();
                 this.formulaSystem.generateFormula();
                
                // Hide pause menu
                this.hidePauseMenu();
                
                console.log('Game restarted!');
            }

            handleCollisions() {
                if (!this.player || !this.enemySpawner) return;
                
                const collidingEnemy = this.enemySpawner.checkCollisions(this.player);
                if (collidingEnemy) {
                    // Deal damage to player
                    this.dealDamageToPlayer(10);
                    
                    // Enemy takes minor damage from collision
                    collidingEnemy.takeDamage(5);
                    
                    console.log(`Collision! Enemy health: ${collidingEnemy.health}`);
                }
            }

            handleFormulaInput() {
                if (this.isPaused) return; // Disable formula input when paused
                
                const spaceCurrentlyPressed = this.inputHandler.isSpacePressed();
                
                // Detect space key press (not held)
                if (spaceCurrentlyPressed && !this.spacePressed) {
                    this.formulaSystem.toggleFormulaHUD();
                }
                
                this.spacePressed = spaceCurrentlyPressed;
            }

            togglePauseMenu() {
                this.isPaused = !this.isPaused;
                
                if (this.isPaused) {
                    this.showPauseMenu();
                } else {
                    this.hidePauseMenu();
                }
            }

            showPauseMenu() {
                // Exit combat mode safely
                if (this.combatMode) {
                    this.exitCombatMode();
                }
                
                // Hide formula HUD to prevent cheating
                this.formulaSystem.hideFormulaHUD();
                
                // Update pause menu stats
                this.updatePauseStats();
                
                // Show pause menu
                this.pauseMenu.style.display = 'block';
                
                console.log('Game paused');
            }

            hidePauseMenu() {
                this.pauseMenu.style.display = 'none';
                console.log('Game resumed');
            }

            updatePauseStats() {
                const total = this.formulaSystem.correctAnswers + this.formulaSystem.incorrectAnswers;
                const accuracy = total > 0 ? Math.round((this.formulaSystem.correctAnswers / total) * 100) : 100;
                
                this.pauseStats.score.textContent = this.formulaSystem.score;
                this.pauseStats.correct.textContent = this.formulaSystem.correctAnswers;
                this.pauseStats.incorrect.textContent = this.formulaSystem.incorrectAnswers;
                this.pauseStats.accuracy.textContent = accuracy + '%';
                this.pauseStats.health.textContent = `${this.playerHealth}/${this.playerMaxHealth}`;
            }

            resumeGame() {
                this.isPaused = false;
                this.hidePauseMenu();
            }

            render() {
                // Render enemies first (behind player)
                if (this.enemySpawner) {
                    this.enemySpawner.render(this.ctx);
                }
                
                // Render player
                if (this.player) {
                    this.player.render(this.ctx);
                }
                
                // Render player health bar
                this.renderPlayerHealthBar();
                
                // Render game over screen
                if (this.isGameOver) {
                    this.renderGameOverScreen();
                }
                
                // Render combat mode indicator
                if (this.combatMode && this.targetedEnemy && !this.isPaused) {
                    this.renderCombatModeIndicator();
                }
                
                // Render pause indicator on canvas
                if (this.isPaused && !this.isGameOver) {
                    this.renderPauseIndicator();
                }
            }

            renderPlayerHealthBar() {
                if (this.playerHealth >= this.playerMaxHealth) return;
                
                const barWidth = 200;
                const barHeight = 8;
                const barX = 10;
                const barY = 120;
                
                // Background
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(barX, barY, barWidth, barHeight);
                
                // Health
                const healthPercent = this.playerHealth / this.playerMaxHealth;
                const healthColor = healthPercent > 0.6 ? '#00ff00' : healthPercent > 0.3 ? '#ffff00' : '#ff0000';
                this.ctx.fillStyle = healthColor;
                this.ctx.fillRect(barX, barY, barWidth * healthPercent, barHeight);
                
                // Border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(barX, barY, barWidth, barHeight);
                
                // Text
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '12px Courier New';
                this.ctx.fillText(`Health: ${this.playerHealth}/${this.playerMaxHealth}`, barX, barY - 5);
            }

            renderGameOverScreen() {
                // Dark overlay
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Game Over text
                this.ctx.fillStyle = '#ff0000';
                this.ctx.font = '48px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = '#ff000080';
                this.ctx.shadowBlur = 20;
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 50);
                
                // Restart info
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '20px Courier New';
                this.ctx.shadowBlur = 10;
                this.ctx.fillText('Automatischer Neustart in 3 Sekunden...', this.canvas.width / 2, this.canvas.height / 2 + 20);
                
                // Final score
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '24px Courier New';
                this.ctx.fillText(`Endpunktzahl: ${this.formulaSystem.score}`, this.canvas.width / 2, this.canvas.height / 2 + 60);
            }

            renderCombatModeIndicator() {
                if (!this.targetedEnemy) return;
                
                // Combat mode banner
                const bannerHeight = 40;
                this.ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, bannerHeight);
                
                // Border
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(0, 0, this.canvas.width, bannerHeight);
                
                // Text
                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '16px Courier New';
                this.ctx.textAlign = 'center';
                this.ctx.shadowColor = '#000000';
                this.ctx.shadowBlur = 5;
                this.ctx.fillText(`KAMPFMODUS - L√∂se: ${this.targetedEnemy.assignedFormula.text}`, this.canvas.width / 2, 25);
                
                // Target line to enemy
                this.ctx.strokeStyle = '#ff000080';
                this.ctx.lineWidth = 3;
                this.ctx.setLineDash([10, 5]);
                this.ctx.beginPath();
                this.ctx.moveTo(this.player.x, this.player.y);
                this.ctx.lineTo(this.targetedEnemy.x, this.targetedEnemy.y);
                this.ctx.stroke();
                this.ctx.setLineDash([]); // Reset line dash
            }

            renderPauseIndicator() {
                // Dim the game background
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Pause indicator in corner
                this.ctx.fillStyle = '#ffff00';
                this.ctx.font = '20px Courier New';
                this.ctx.textAlign = 'right';
                this.ctx.shadowColor = '#ffff0080';
                this.ctx.shadowBlur = 10;
                this.ctx.fillText('‚è∏ PAUSIERT', this.canvas.width - 20, 40);
            }

            clearCanvas() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            renderBackground() {
                // Create a subtle grid pattern for the dungeon feel
                this.ctx.strokeStyle = '#222';
                this.ctx.lineWidth = 1;
                
                const gridSize = 50;
                
                // Vertical lines
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }

                // Add some neon-style corner highlights
                this.ctx.fillStyle = '#00ff0020';
                this.ctx.fillRect(0, 0, 100, 100);
                this.ctx.fillRect(this.canvas.width - 100, 0, 100, 100);
                this.ctx.fillRect(0, this.canvas.height - 100, 100, 100);
                this.ctx.fillRect(this.canvas.width - 100, this.canvas.height - 100, 100, 100);
            }

            renderDebugInfo() {
                this.ctx.fillStyle = '#00ff00';
                this.ctx.font = '12px Courier New';
                
                const playerDebug = this.player ? this.player.getDebugInfo() : null;
                const inputDebug = this.inputHandler ? this.inputHandler.getDebugInfo() : 'None';
                const formulaDebug = this.formulaSystem ? this.formulaSystem.getDebugInfo() : null;
                const enemyDebug = this.enemySpawner ? this.enemySpawner.getDebugInfo() : null;
                
                const gameStatus = this.isGameOver ? 'Game Over' : this.isPaused ? 'Paused' : 'Running';
                
                const debugInfo = [
                    `Canvas: ${this.canvas.width}x${this.canvas.height}`,
                    `Engine Status: ${gameStatus}`,
                                         `Phase: 2.2+ - Pause System`,
                     playerDebug ? `Player Pos: ${playerDebug.position}` : 'Player: None',
                     `Player Health: ${this.playerHealth}/${this.playerMaxHealth}`,
                     `Combat Mode: ${this.combatMode ? 'Active' : 'Inactive'}`,
                     formulaDebug ? `Score: ${formulaDebug.score} | High: ${formulaDebug.highScore}` : '',
                     formulaDebug ? `Combo: ${formulaDebug.combo}/${formulaDebug.maxCombo} (${formulaDebug.correct}/${formulaDebug.incorrect})` : '',
                    enemyDebug ? `Enemies: ${enemyDebug.enemyCount}, Next: ${enemyDebug.nextSpawn}s` : 'Enemies: None',
                    `Input: ${inputDebug}`
                ];
                
                debugInfo.forEach((info, index) => {
                    if (info) { // Only render non-empty strings
                        this.ctx.fillText(info, 10, this.canvas.height - 105 + (index * 15));
                    }
                });
            }
        }

        // Initialize game when page loads
        window.addEventListener('load', () => {
            console.log('üéÆ Formel-Fury-Shooter initializing...');
            const game = new GameEngine();
            console.log('‚úÖ Game engine started successfully!');
            
            // Make game accessible globally for debugging
            window.game = game;
        });
    </script>
</body>
</html>
