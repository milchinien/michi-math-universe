<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Polstellen-Panik - Mathematik Spiel</title>
    
    <!-- KaTeX CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
        }

        .game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00ffff;
            box-shadow: 0 2px 10px rgba(0, 255, 255, 0.3);
        }

        .title {
            font-size: 24px;
            font-weight: bold;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .stats {
            display: flex;
            gap: 30px;
            font-size: 18px;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .health { color: #ff4444; }
        .score { color: #44ff44; }
        .level { color: #ffff44; }

        .game-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #gameCanvas {
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, #1a1a2e 0%, #0a0a0a 100%);
            cursor: crosshair;
        }

        .function-display {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            pointer-events: none;
            z-index: 10;
        }

        .function-card {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid;
            border-radius: 8px;
            padding: 10px;
            min-width: 120px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .function-card {
            border-color: #9696ff;
            box-shadow: 0 0 15px rgba(150, 150, 255, 0.5);
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .btn {
            background: rgba(0, 255, 255, 0.2);
            border: 2px solid #00ffff;
            color: #00ffff;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #00ffff;
            border-radius: 10px;
            padding: 30px;
            max-width: 600px;
            text-align: center;
            z-index: 100;
        }

        .instructions.hidden { display: none; }

        .instructions h2 {
            color: #00ffff;
            margin-bottom: 20px;
        }

        .instructions p {
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            z-index: 100;
        }

        .game-over.hidden { display: none; }

        .game-over h2 {
            color: #ff4444;
            margin-bottom: 20px;
            font-size: 32px;
        }

        @keyframes explosion {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .explosion {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #ffff00 0%, #ff4444 50%, transparent 100%);
            animation: explosion 0.5s ease-out forwards;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <div class="title">üéØ Polstellen-Panik</div>
            <div class="stats">
                <div class="stat health">‚ù§Ô∏è Leben: <span id="healthDisplay">3</span></div>
                <div class="stat score">üéØ Score: <span id="scoreDisplay">0</span></div>
                <div class="stat level">üìä Level: <span id="levelDisplay">1</span></div>
            </div>
        </div>

        <div class="game-area">
            <canvas id="gameCanvas"></canvas>
            <div class="function-display" id="functionDisplay"></div>
        </div>

        <div class="controls">
            <button class="btn" id="pauseBtn">‚è∏Ô∏è Pause</button>
            <button class="btn" id="restartBtn">üîÑ Neustart</button>
            <button class="btn" id="helpBtn">‚ùì Hilfe</button>
        </div>

        <div class="instructions" id="instructions">
            <h2>üéØ Polstellen-Panik - Anleitung</h2>
            <p><strong>Ziel:</strong> Du bist im Koordinatenursprung (x=0) gefangen! Schie√üe nur die gef√§hrlichen Funktions-Monster ab.</p>
            <p><strong>üî¥ Gef√§hrlich:</strong> Monster mit Polstellen bei x=0 (Nenner=0, Z√§hler‚â†0)</p>
            <p><strong>üü¢ Harmlos:</strong> Monster ohne Polstelle bei x=0</p>
            <p><strong>üü° Getarnt:</strong> Monster mit hebbarer L√ºcke bei x=0 (Nenner=0, Z√§hler=0) - geben Power-Ups!</p>
            <p><strong>Steuerung:</strong> Maus zum Zielen, Klicken zum Schie√üen</p>
            <p><strong>Punkte:</strong> Richtiger Abschuss +100, Power-Up +50, Falscher Abschuss -50</p>
            <button class="btn" onclick="startGame()">üöÄ Spiel starten!</button>
        </div>

        <div class="game-over hidden" id="gameOver">
            <h2>üíÄ Game Over!</h2>
            <p>Endpunktzahl: <span id="finalScore">0</span></p>
            <p>Erreichtes Level: <span id="finalLevel">1</span></p>
            <button class="btn" onclick="restartGame()">üîÑ Nochmal spielen</button>
        </div>
    </div>

    <!-- Math.js -->
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.11.0/lib/browser/math.min.js"></script>
    <!-- KaTeX -->
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>

    <script>
        // Game State
        let gameState = {
            playing: false,
            paused: false,
            health: 3,
            score: 0,
            level: 1,
            monsters: [],
            particles: [],
            projectiles: [],
            lastSpawn: 0,
            spawnRate: 4000,
            canvas: null,
            ctx: null,
            mouseX: 0,
            mouseY: 0
        };

        // Math Analyzer
        class MathAnalyzer {
            static hasPolstelle(functionString, x = 0) {
                try {
                    // More comprehensive check for polstellen at x=0
                    if (functionString.includes('/x') && !functionString.includes('/(x-') && !functionString.includes('/(x+')) {
                        // Check if numerator is also zero at x=0
                        const numerator = functionString.split('/')[0];
                        const numeratorAtZero = this.evaluateExpression(numerator, 0);
                        return Math.abs(numeratorAtZero) > 0.0001; // Polstelle if numerator ‚â† 0
                    }
                    if (functionString.includes('/(x^2)') || functionString.includes('/(x*x)')) {
                        const numerator = functionString.split('/')[0];
                        const numeratorAtZero = this.evaluateExpression(numerator, 0);
                        return Math.abs(numeratorAtZero) > 0.0001;
                    }
                    return false;
                } catch (e) {
                    return false;
                }
            }

            static hasRemovableGap(functionString, x = 0) {
                try {
                    // Check for patterns like x^2/x, (x^2)/x, etc.
                    if (functionString.match(/x\^?\d*\/x/) && !functionString.includes('x-') && !functionString.includes('x+')) {
                        return true;
                    }
                    // Check if both numerator and denominator are zero
                    if (functionString.includes('/x')) {
                        const numerator = functionString.split('/')[0];
                        const numeratorAtZero = this.evaluateExpression(numerator, 0);
                        return Math.abs(numeratorAtZero) < 0.0001; // Removable if numerator = 0
                    }
                    return false;
                } catch (e) {
                    return false;
                }
            }

            static evaluateExpression(expr, x) {
                try {
                    // Handle parentheses and common patterns
                    let cleanExpr = expr.replace(/\(/g, '').replace(/\)/g, '');
                    cleanExpr = cleanExpr.replace(/\^/g, '**');
                    cleanExpr = cleanExpr.replace(/x/g, `(${x})`);
                    cleanExpr = cleanExpr.replace(/\*/g, '*');
                    return eval(cleanExpr);
                } catch (e) {
                    return 0;
                }
            }

            static evaluateFunction(functionString, x) {
                try {
                    // Handle division by zero cases
                    if (Math.abs(x) < 0.001) {
                        // Near zero, check for special behavior
                        if (this.hasPolstelle(functionString, 0)) {
                            return x > 0 ? 1000 : -1000; // Simulate approach to infinity
                        }
                        if (this.hasRemovableGap(functionString, 0)) {
                            // For removable gaps, use limit
                            return this.evaluateFunction(functionString, 0.001);
                        }
                    }
                    
                    let expr = functionString.replace(/\^/g, '**');
                    expr = expr.replace(/x/g, `(${x})`);
                    const result = eval(expr);
                    
                    // Clamp extreme values for display
                    if (!isFinite(result) || Math.abs(result) > 1000) {
                        return result > 0 ? 1000 : -1000;
                    }
                    return result;
                } catch (e) {
                    return 0;
                }
            }
        }

        // Function Generator
        class FunctionGenerator {
            static generateFunction(difficulty = 1) {
                // Ensure balanced distribution of function types
                const dangerousFunctions = ['1/x', '2/x', '(x-1)/x', '(x+1)/x', '3/x', '(2*x-1)/x'];
                const harmlessFunctions = ['x/(x-1)', 'x/(x+1)', 'x/(x-2)', 'x/(x+2)', '(x+2)/(x-1)', '(x-2)/(x+1)'];
                const removableFunctions = ['(x^2)/x', '(x^3)/x', '(2*x^2)/x', '(x^2-x)/x'];
                
                // Force distribution: 45% dangerous, 45% harmless, 10% removable (reduced yellow)
                const rand = Math.random();
                let selectedFunction;
                
                if (rand < 0.45) {
                    // Dangerous functions
                    selectedFunction = dangerousFunctions[Math.floor(Math.random() * dangerousFunctions.length)];
                } else if (rand < 0.9) {
                    // Harmless functions
                    selectedFunction = harmlessFunctions[Math.floor(Math.random() * harmlessFunctions.length)];
                } else {
                    // Removable gap functions (reduced probability)
                    selectedFunction = removableFunctions[Math.floor(Math.random() * removableFunctions.length)];
                }
                
                return selectedFunction;
            }

            static analyzeFunction(functionString) {
                const hasPolAt0 = MathAnalyzer.hasPolstelle(functionString, 0);
                const hasRemovableGapAt0 = MathAnalyzer.hasRemovableGap(functionString, 0);
                
                let type = 'harmless';
                if (hasPolAt0) type = 'dangerous';
                else if (hasRemovableGapAt0) type = 'removable';
                
                return { type, hasPolAt0, hasRemovableGapAt0 };
            }
        }

        // Monster Class
        class Monster {
            constructor(functionString, startX, speed, canvas, direction = 1) {
                this.function = functionString;
                this.x = startX;
                this.speed = speed; // Keep speed positive, handle direction in update
                this.direction = direction; // 1 for right-to-left, -1 for left-to-right
                this.canvas = canvas;
                this.analysis = FunctionGenerator.analyzeFunction(functionString);
                this.type = this.analysis.type;
                this.radius = 20;
                this.alive = true;
                this.reachedCenter = false;
                this.y = this.calculateY();
                this.glowIntensity = 0;
                this.glowDirection = 1;
                this.pathPoints = []; // Store path points for curve drawing
                this.generatePath();
            }

            generatePath() {
                // Generate path points for the entire visible range
                this.pathPoints = [];
                const centerX = this.canvas.width / 2;
                
                for (let canvasX = 0; canvasX <= this.canvas.width; canvasX += 10) {
                    const mathX = (canvasX - centerX) / 50;
                    const yValue = MathAnalyzer.evaluateFunction(this.function, mathX);
                    
                    if (isFinite(yValue) && Math.abs(yValue) < 20) {
                        const canvasY = this.canvas.height / 2 - (yValue * 30);
                        if (canvasY >= 0 && canvasY <= this.canvas.height) {
                            this.pathPoints.push({ x: canvasX, y: canvasY });
                        }
                    }
                }
            }

            calculateY() {
                try {
                    // Convert canvas x to mathematical x coordinate
                    const mathX = (this.x - this.canvas.width / 2) / 50; // Scale factor
                    const yValue = MathAnalyzer.evaluateFunction(this.function, mathX);
                    
                    if (isNaN(yValue) || !isFinite(yValue)) {
                        return this.canvas.height / 2;
                    }
                    
                    // Convert mathematical y to canvas y (inverted)
                    const scaledY = this.canvas.height / 2 - (yValue * 30);
                    return Math.max(50, Math.min(this.canvas.height - 50, scaledY));
                } catch (e) {
                    return this.canvas.height / 2;
                }
            }

            update(deltaTime) {
                if (!this.alive) return;
                
                // Move based on direction
                if (this.direction === 1) {
                    // Moving from right to left (toward center)
                    this.x -= this.speed * deltaTime / 1000;
                } else {
                    // Moving from left to right (toward center)
                    this.x += this.speed * deltaTime / 1000;
                }
                this.y = this.calculateY();
                
                this.glowIntensity += this.glowDirection * deltaTime / 500;
                if (this.glowIntensity > 1) {
                    this.glowIntensity = 1;
                    this.glowDirection = -1;
                } else if (this.glowIntensity < 0) {
                    this.glowIntensity = 0;
                    this.glowDirection = 1;
                }
                
                // Check if reached center (y-axis) from either direction
                const centerX = this.canvas.width / 2;
                if (Math.abs(this.x - centerX) <= 25 && !this.reachedCenter) {
                    this.reachedCenter = true;
                    this.handleReachCenter();
                }
            }

            handleReachCenter() {
                // Reveal true color when reaching center
                this.revealType();
                
                if (this.type === 'dangerous') {
                    gameState.health--;
                    gameState.score = Math.max(0, gameState.score - 100);
                    this.createEnergyBeam();
                    playSound('damage');
                } else if (this.type === 'removable') {
                    gameState.score += 50;
                    this.createPowerUpEffect();
                    playSound('powerup');
                }
                this.alive = false;
            }

            revealType() {
                // Show true color briefly when type is revealed
                const canvas = this.canvas;
                const ctx = canvas.getContext('2d');
                
                let revealColor;
                switch (this.type) {
                    case 'dangerous': revealColor = '#ff4444'; break;
                    case 'harmless': revealColor = '#44ff44'; break;
                    case 'removable': revealColor = '#ffaa44'; break;
                }
                
                // Create a reveal effect at monster position
                const reveal = {
                    x: this.x,
                    y: this.y,
                    color: revealColor,
                    life: 1500,
                    maxLife: 1500,
                    type: 'reveal'
                };
                gameState.particles.push(reveal);
            }

            createEnergyBeam() {
                const beam = {
                    x: this.canvas.width / 2,
                    y: this.y,
                    life: 1000,
                    type: 'beam'
                };
                gameState.particles.push(beam);
            }

            createPowerUpEffect() {
                for (let i = 0; i < 10; i++) {
                    const particle = {
                        x: this.x,
                        y: this.y,
                        vx: (Math.random() - 0.5) * 200,
                        vy: (Math.random() - 0.5) * 200,
                        life: 1000,
                        maxLife: 1000,
                        type: 'powerup'
                    };
                    gameState.particles.push(particle);
                }
            }

            draw(ctx) {
                if (!this.alive) return;
                
                // Draw function curve (dashed line)
                this.drawPath(ctx);
                
                // All monsters have neutral color until revealed
                const neutralColor = `rgba(150, 150, 255, ${0.8 + this.glowIntensity * 0.2})`; // Light blue/purple
                
                ctx.shadowBlur = 20 + this.glowIntensity * 20;
                ctx.shadowColor = neutralColor;
                
                ctx.fillStyle = neutralColor;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.function, this.x, this.y - this.radius - 10);
            }

            drawPath(ctx) {
                if (this.pathPoints.length < 2) return;
                
                // Set up dashed line style
                ctx.save();
                ctx.setLineDash([5, 5]);
                ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(this.pathPoints[0].x, this.pathPoints[0].y);
                
                for (let i = 1; i < this.pathPoints.length; i++) {
                    ctx.lineTo(this.pathPoints[i].x, this.pathPoints[i].y);
                }
                
                ctx.stroke();
                ctx.restore();
            }

            isClicked(mouseX, mouseY) {
                const dx = mouseX - this.x;
                const dy = mouseY - this.y;
                // Larger hitbox for easier clicking
                return Math.sqrt(dx * dx + dy * dy) < (this.radius + 15);
            }
        }

        // Projectile Class
        class Projectile {
            constructor(startX, startY, targetX, targetY) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;
                this.speed = 800; // pixels per second
                this.alive = true;
                
                // Calculate direction
                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                this.vx = (dx / distance) * this.speed;
                this.vy = (dy / distance) * this.speed;
                
                // Visual properties
                this.trail = [];
            }
            
            update(deltaTime) {
                if (!this.alive) return;
                
                // Add current position to trail
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 8) {
                    this.trail.shift();
                }
                
                // Move projectile
                this.x += this.vx * deltaTime / 1000;
                this.y += this.vy * deltaTime / 1000;
                
                // Check if reached target area
                const dx = this.x - this.targetX;
                const dy = this.y - this.targetY;
                if (Math.sqrt(dx * dx + dy * dy) < 20) {
                    this.alive = false;
                }
                
                // Remove if off screen
                if (this.x < -50 || this.x > gameState.canvas.width + 50 || 
                    this.y < -50 || this.y > gameState.canvas.height + 50) {
                    this.alive = false;
                }
            }
            
            draw(ctx) {
                if (!this.alive) return;
                
                // Draw trail
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                for (let i = 0; i < this.trail.length - 1; i++) {
                    const alpha = (i + 1) / this.trail.length;
                    ctx.globalAlpha = alpha * 0.6;
                    
                    if (i === 0) {
                        ctx.moveTo(this.trail[i].x, this.trail[i].y);
                    } else {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                }
                ctx.stroke();
                ctx.globalAlpha = 1;
                
                // Draw projectile
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        // Game Engine
        class GameEngine {
            constructor() {
                this.lastTime = 0;
                this.animationId = null;
            }

            start() {
                gameState.playing = true;
                gameState.paused = false;
                this.lastTime = performance.now();
                this.gameLoop();
            }

            stop() {
                gameState.playing = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            pause() {
                gameState.paused = !gameState.paused;
                if (!gameState.paused) {
                    this.lastTime = performance.now();
                    this.gameLoop();
                }
            }

            gameLoop(currentTime = performance.now()) {
                if (!gameState.playing || gameState.paused) return;
                
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime, currentTime);
                this.render();
                
                this.animationId = requestAnimationFrame((time) => this.gameLoop(time));
            }

            update(deltaTime, currentTime) {
                if (currentTime - gameState.lastSpawn > gameState.spawnRate) {
                    this.spawnMonster();
                    gameState.lastSpawn = currentTime;
                }
                
                gameState.monsters = gameState.monsters.filter(monster => {
                    monster.update(deltaTime);
                    // Keep monsters that are alive and still on screen (from either direction)
                    const onScreen = monster.x > -150 && monster.x < gameState.canvas.width + 150;
                    if (!monster.alive || !onScreen) {
                        console.log('Removing monster:', monster.function, 'alive:', monster.alive, 'x:', monster.x, 'onScreen:', onScreen);
                    }
                    return monster.alive && onScreen;
                });
                
                gameState.particles = gameState.particles.filter(particle => {
                    particle.life -= deltaTime;
                    if (particle.type === 'powerup') {
                        particle.x += particle.vx * deltaTime / 1000;
                        particle.y += particle.vy * deltaTime / 1000;
                    }
                    return particle.life > 0;
                });
                
                // Update projectiles
                gameState.projectiles = gameState.projectiles.filter(projectile => {
                    projectile.update(deltaTime);
                    return projectile.alive;
                });
                
                if (gameState.health <= 0) {
                    this.gameOver();
                }
                
                const newLevel = Math.floor(gameState.score / 500) + 1;
                if (newLevel > gameState.level) {
                    gameState.level = newLevel;
                    gameState.spawnRate = Math.max(2000, 4000 - (gameState.level * 300)); // Slower spawn rate
                }
                
                this.updateUI();
            }

            spawnMonster() {
                const canvas = gameState.canvas;
                const functionString = FunctionGenerator.generateFunction(gameState.level);
                
                // Alternate spawn direction
                const direction = gameState.monsters.length % 2 === 0 ? 1 : -1;
                let startX;
                const speed = 30 + gameState.level * 5;
                
                if (direction === 1) {
                    // Spawn from right (moving left)
                    startX = canvas.width + 100;
                } else {
                    // Spawn from left (moving right)
                    startX = -100;
                }
                
                const monster = new Monster(functionString, startX, speed, canvas, direction);
                gameState.monsters.push(monster);
                
                console.log('Spawned monster:', functionString, 'Type:', monster.type, 'Direction:', direction);
                this.updateFunctionDisplay();
            }

            render() {
                const ctx = gameState.ctx;
                const canvas = gameState.canvas;
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                this.drawCoordinateSystem(ctx, canvas);
                this.drawPlayer(ctx, canvas);
                
                gameState.monsters.forEach(monster => monster.draw(ctx));
                this.drawParticles(ctx);
                this.drawProjectiles(ctx);
            }

            drawCoordinateSystem(ctx, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, canvas.height);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(canvas.width, centerY);
                ctx.stroke();
                
                ctx.fillStyle = '#00ffff';
                ctx.font = '16px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('(0,0)', centerX + 20, centerY - 10);
            }

            drawPlayer(ctx, canvas) {
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.fillStyle = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00ffff';
                ctx.beginPath();
                ctx.arc(centerX, centerY, 25, 0, Math.PI * 2);
                ctx.fill();
                
                const angle = Math.atan2(gameState.mouseY - centerY, gameState.mouseX - centerX);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + Math.cos(angle) * 30, centerY + Math.sin(angle) * 30);
                ctx.stroke();
                
                ctx.shadowBlur = 0;
            }

            drawParticles(ctx) {
                gameState.particles.forEach(particle => {
                    if (particle.type === 'beam') {
                        ctx.strokeStyle = '#ff4444';
                        ctx.lineWidth = 5;
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = '#ff4444';
                        ctx.beginPath();
                        ctx.moveTo(particle.x, 0);
                        ctx.lineTo(particle.x, gameState.canvas.height);
                        ctx.stroke();
                        ctx.shadowBlur = 0;
                    } else if (particle.type === 'powerup') {
                        const alpha = particle.life / particle.maxLife;
                        ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (particle.type === 'reveal') {
                        // Type reveal effect
                        const alpha = particle.life / particle.maxLife;
                        ctx.fillStyle = particle.color;
                        ctx.shadowBlur = 15;
                        ctx.shadowColor = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, 8 * (1 - alpha), 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }
                });
            }

            drawProjectiles(ctx) {
                gameState.projectiles.forEach(projectile => projectile.draw(ctx));
            }

            updateFunctionDisplay() {
                const display = document.getElementById('functionDisplay');
                display.innerHTML = '';
                
                gameState.monsters.slice(0, 5).forEach(monster => {
                    const card = document.createElement('div');
                    card.className = `function-card ${monster.type}`;
                    card.textContent = monster.function;
                    display.appendChild(card);
                });
            }

            updateUI() {
                document.getElementById('healthDisplay').textContent = gameState.health;
                document.getElementById('scoreDisplay').textContent = gameState.score;
                document.getElementById('levelDisplay').textContent = gameState.level;
            }

            gameOver() {
                this.stop();
                document.getElementById('finalScore').textContent = gameState.score;
                document.getElementById('finalLevel').textContent = gameState.level;
                document.getElementById('gameOver').classList.remove('hidden');
            }
        }

        // Audio System
        function playSound(type) {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                switch (type) {
                    case 'shoot':
                        oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(600, audioContext.currentTime + 0.1);
                        break;
                    case 'hit_correct':
                        // Positive sound - ascending notes
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.2);
                        break;
                    case 'hit_wrong':
                        // Negative sound - descending notes
                        oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(150, audioContext.currentTime + 0.3);
                        break;
                    case 'damage':
                        oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);
                        break;
                    case 'powerup':
                        oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                        oscillator.frequency.exponentialRampToValueAtTime(800, audioContext.currentTime + 0.3);
                        break;
                }
                
                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.4);
            } catch (e) {
                console.log('Audio not supported:', e);
            }
        }

        // Game instance
        let gameEngine = new GameEngine();

        // Initialize game
        function initGame() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            
            function resizeCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight - 120;
            }
            
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            gameState.canvas = canvas;
            gameState.ctx = ctx;
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                gameState.mouseX = e.clientX - rect.left;
                gameState.mouseY = e.clientY - rect.top;
            });
            
            canvas.addEventListener('click', (e) => {
                if (!gameState.playing || gameState.paused) return;
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                console.log('Click at:', mouseX, mouseY);
                console.log('Monsters:', gameState.monsters.length);
                
                // Check if any monster was clicked
                let hitMonster = null;
                for (let i = gameState.monsters.length - 1; i >= 0; i--) {
                    const monster = gameState.monsters[i];
                    console.log('Checking monster at:', monster.x, monster.y, 'alive:', monster.alive);
                    
                    if (monster.alive && monster.isClicked(mouseX, mouseY)) {
                        hitMonster = monster;
                        console.log('Hit monster type:', monster.type);
                        
                        // Create projectile
                        const centerX = gameState.canvas.width / 2;
                        const centerY = gameState.canvas.height / 2;
                        const projectile = new Projectile(centerX, centerY, mouseX, mouseY);
                        gameState.projectiles.push(projectile);
                        
                        // Play shoot sound
                        playSound('shoot');
                        
                        // Reveal monster type and score
                        monster.revealType();
                        
                        // Score based on monster type with appropriate sounds
                        if (monster.type === 'dangerous') {
                            gameState.score += 100;
                            console.log('Correct hit! +100 points');
                            playSound('hit_correct');
                        } else {
                            gameState.score = Math.max(0, gameState.score - 50);
                            console.log('Wrong target! -50 points');
                            playSound('hit_wrong');
                        }
                        
                        // Create colored explosion effect based on monster type
                        const explosion = document.createElement('div');
                        explosion.className = 'explosion';
                        explosion.style.position = 'fixed';
                        explosion.style.left = (e.clientX - 25) + 'px';
                        explosion.style.top = (e.clientY - 25) + 'px';
                        explosion.style.zIndex = '1000';
                        
                        // Set explosion color based on monster type
                        let explosionColor;
                        switch (monster.type) {
                            case 'dangerous': explosionColor = 'radial-gradient(circle, #ff4444 0%, #ffff00 50%, transparent 100%)'; break;
                            case 'harmless': explosionColor = 'radial-gradient(circle, #44ff44 0%, #ffff00 50%, transparent 100%)'; break;
                            case 'removable': explosionColor = 'radial-gradient(circle, #ffaa44 0%, #ffff00 50%, transparent 100%)'; break;
                        }
                        explosion.style.background = explosionColor;
                        
                        document.body.appendChild(explosion);
                        setTimeout(() => explosion.remove(), 500);
                        
                        monster.alive = false;
                        break;
                    }
                }
                
                if (!hitMonster) {
                    console.log('No monster hit');
                }
            });
            
            // Button events
            document.getElementById('pauseBtn').addEventListener('click', () => {
                gameEngine.pause();
                document.getElementById('pauseBtn').textContent = gameState.paused ? '‚ñ∂Ô∏è Weiter' : '‚è∏Ô∏è Pause';
            });
            
            document.getElementById('restartBtn').addEventListener('click', restartGame);
            
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('instructions').classList.remove('hidden');
                gameEngine.pause();
            });
        }

        function startGame() {
            document.getElementById('instructions').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            
            // Reset game state
            gameState.health = 3;
            gameState.score = 0;
            gameState.level = 1;
            gameState.monsters = [];
            gameState.particles = [];
            gameState.projectiles = [];
            gameState.lastSpawn = 0;
            gameState.spawnRate = 4000;
            
            gameEngine.start();
        }

        function restartGame() {
            gameEngine.stop();
            startGame();
        }

        // Initialize when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
